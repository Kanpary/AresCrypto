<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuasarProtect Advanced - 15 Camadas de Prote√ß√£o</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e1b4b 0%, #312e81 50%, #4c1d95 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 35px;
            box-shadow: 0 25px 70px rgba(79, 70, 229, 0.4);
            max-width: 700px;
            width: 100%;
            border: 3px solid #4f46e5;
        }

        h1 {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 10px;
            font-size: 36px;
            font-weight: 900;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .security-badge {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 25px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(79, 70, 229, 0.3);
        }

        .security-badge small {
            font-size: 11px;
            opacity: 0.95;
        }

        .layers-list {
            background: #eef2ff;
            border-left: 4px solid #4f46e5;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }

        .layers-list h4 {
            color: #312e81;
            margin-bottom: 10px;
            font-size: 14px;
            position: sticky;
            top: 0;
            background: #eef2ff;
            padding: 5px 0;
        }

        .layers-list ul {
            list-style: none;
            padding-left: 0;
        }

        .layers-list li {
            padding: 5px 0;
            color: #444;
            line-height: 1.6;
        }

        .layers-list li:before {
            content: "‚ö° ";
            color: #4f46e5;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .file-input-label {
            display: block;
            padding: 25px;
            background: #eef2ff;
            border: 3px dashed #4f46e5;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #312e81;
        }

        .file-input-label:hover {
            background: #ddd6fe;
            border-color: #7c3aed;
            transform: translateY(-2px);
        }

        #fileInput {
            display: none;
        }

        .file-name {
            margin-top: 12px;
            padding: 12px;
            background: #ddd6fe;
            border-radius: 10px;
            font-size: 14px;
            word-break: break-all;
            display: none;
            color: #312e81;
            font-weight: 600;
            border: 2px solid #c4b5fd;
        }

        .btn {
            width: 100%;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .btn-encrypt {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.4);
        }

        .btn-encrypt:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(79, 70, 229, 0.5);
        }

        .btn-encrypt:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #eef2ff;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
            border: 2px solid #c4b5fd;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4f46e5 0%, #7c3aed 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            display: none;
        }

        .status.info {
            background: #dbeafe;
            color: #1e40af;
            display: block;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            display: block;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            display: block;
        }

        .warning-box {
            background: #fef3c7;
            border: 2px solid #f59e0b;
            padding: 18px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 13px;
            color: #444;
        }

        .warning-box strong {
            color: #d97706;
            font-size: 14px;
        }

        .tech-info {
            margin-top: 25px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 10px;
            font-size: 12px;
            border: 2px solid #e5e7eb;
        }

        .tech-info h3 {
            color: #312e81;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .tech-info ul {
            list-style: none;
            padding-left: 0;
        }

        .tech-info li {
            padding: 6px 0;
            line-height: 1.5;
            color: #374151;
        }

        .tech-info li strong {
            color: #4f46e5;
        }

        .password-wrapper {
            margin-bottom: 20px;
        }

        .password-wrapper label {
            display: block;
            margin-bottom: 8px;
            color: #312e81;
            font-weight: bold;
            font-size: 14px;
        }

        .password-wrapper input {
            width: 100%;
            padding: 14px;
            border: 2px solid #4f46e5;
            border-radius: 10px;
            font-size: 15px;
            transition: all 0.3s;
        }

        .password-wrapper input:focus {
            outline: none;
            border-color: #7c3aed;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.1);
        }

        .password-strength {
            margin-top: 8px;
            font-size: 13px;
            color: #666;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° QuasarProtect Advanced</h1>
        <p class="subtitle">Sistema de Criptografia com 15 Camadas de Prote√ß√£o Multin√≠vel</p>

        <div class="security-badge">
            ‚úÖ 15 Camadas de Prote√ß√£o Ativas<br>
            <small>AES-256-GCM | ChaCha20 | Serpent-256 | Twofish-256 | Polimorfismo Avan√ßado | Metamorfismo Din√¢mico</small>
        </div>

        <div class="layers-list">
            <h4>üõ°Ô∏è Camadas de Seguran√ßa Aplicadas (15 Camadas):</h4>
            <ul>
                <li>Camada 1: XOR Polim√≥rfico Multin√≠vel com Chaves Rotativas</li>
                <li>Camada 2: Transposi√ß√£o de Blocos com Permuta√ß√£o Din√¢mica</li>
                <li>Camada 3: S-Box Din√¢mica Revers√≠vel Multi-Round</li>
                <li>Camada 4: AES-256-GCM (N√≠vel Militar - NIST)</li>
                <li>Camada 5: Rede Feistel (8 rounds com fun√ß√µes complexas)</li>
                <li>Camada 6: Bit-Shifting Metam√≥rfico Avan√ßado</li>
                <li>Camada 7: Code Morphing Revers√≠vel Multi-Padr√£o</li>
                <li>Camada 8: ChaCha20-Poly1305 (Stream Cipher Moderno)</li>
                <li>Camada 9: Serpent-256 (Cifra Finalista AES)</li>
                <li>Camada 10: Twofish-256 (Bruce Schneier)</li>
                <li>Camada 11: DNA Encoding (Sequenciamento ACTG)</li>
                <li>Camada 12: Lattice-Based Obfuscation</li>
                <li>Camada 13: Cellular Automata Cipher (Rule 30)</li>
                <li>Camada 14: PBKDF2-HMAC-SHA512 (200.000 itera√ß√µes)</li>
                <li>Camada 15: SHA3-512 Integrity Hash + HMAC</li>
            </ul>
        </div>

        <div class="password-wrapper">
            <label for="passwordInput">üîë Senha Mestra de Criptografia:</label>
            <input type="password" id="passwordInput" placeholder="Digite uma senha forte (m√≠nimo 12 caracteres)">
            <div id="passwordStrength" class="password-strength"></div>
        </div>

        <div class="file-input-wrapper">
            <label for="fileInput" class="file-input-label">
                üìÅ Selecionar Arquivo para Proteger<br>
                <small style="font-weight: normal; font-size: 11px;">(APK, PNG, JPG, PDF, ZIP, TXT, JS, HTML, CSS)</small>
            </label>
            <input type="file" id="fileInput" accept=".apk,.png,.jpg,.jpeg,.pdf,.zip,.txt,.js,.html,.css">
            <div id="fileName" class="file-name"></div>
        </div>

        <button id="encryptBtn" class="btn btn-encrypt" disabled>
            üîí Aplicar Prote√ß√£o QuasarProtect (15 Camadas)
        </button>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="status" class="status"></div>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Importante - Leia Atentamente:</strong>
            <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                <li><strong>GUARDE SUA SENHA:</strong> Imposs√≠vel descriptografar sem ela</li>
                <li>APKs protegidos precisam de re-assinatura (APK Editor, MT Manager)</li>
                <li>15 camadas de prote√ß√£o tornam an√°lise reversa virtualmente imposs√≠vel</li>
                <li>Processamento 100% local no navegador (nenhum dado enviado)</li>
                <li>Senha m√≠nima: 12 caracteres (recomendado: 16+ com n√∫meros e s√≠mbolos)</li>
            </ul>
        </div>

        <div class="tech-info">
            <h3>üî¨ Tecnologias de Prote√ß√£o Implementadas:</h3>
            <ul>
                <li><strong>AES-256-GCM:</strong> Criptografia de n√≠vel militar aprovada pelo NIST</li>
                <li><strong>ChaCha20-Poly1305:</strong> Stream cipher moderno resistente a timing attacks</li>
                <li><strong>Serpent-256:</strong> Cifra finalista do concurso AES (mais conservadora)</li>
                <li><strong>Twofish-256:</strong> Cifra de Bruce Schneier (128-bit blocks)</li>
                <li><strong>PBKDF2-HMAC-SHA512:</strong> 200.000 itera√ß√µes para deriva√ß√£o de chave</li>
                <li><strong>Polimorfismo Avan√ßado:</strong> XOR multin√≠vel com PRNG criptogr√°fico</li>
                <li><strong>Metamorfismo Din√¢mico:</strong> Bit-shifting e code morphing adaptativos</li>
                <li><strong>DNA Encoding:</strong> Convers√£o byte ‚Üí sequ√™ncia ACTG (bioinform√°tica)</li>
                <li><strong>Lattice-Based Obfuscation:</strong> Ofusca√ß√£o baseada em reticulados</li>
                <li><strong>Cellular Automata:</strong> Regra 30 de Stephen Wolfram</li>
                <li><strong>Rede Feistel 8 rounds:</strong> Fun√ß√µes de mistura complexas</li>
                <li><strong>S-Box Multi-Round:</strong> Substitui√ß√£o din√¢mica com m√∫ltiplas passagens</li>
                <li><strong>SHA3-512 + HMAC:</strong> Hash de integridade p√≥s-quantum ready</li>
            </ul>
            <p style="margin-top: 14px; font-size: 11px; color: #888; line-height: 1.6;">
                <strong>Nota T√©cnica:</strong> QuasarProtect Advanced combina 4 algoritmos militares 
                (AES-256, ChaCha20, Serpent, Twofish) com 11 camadas de polimorfismo, metamorfismo e 
                ofusca√ß√£o avan√ßada. DNA Encoding, Cellular Automata e Lattice Obfuscation adicionam 
                resist√™ncia contra an√°lise est√°tica e din√¢mica. Todas as 15 camadas s√£o revers√≠veis 
                usando a senha correta. PBKDF2 com 200.000 itera√ß√µes dificulta ataques de for√ßa bruta.
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const passwordInput = document.getElementById('passwordInput');
        const passwordStrength = document.getElementById('passwordStrength');
        const encryptBtn = document.getElementById('encryptBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const status = document.getElementById('status');

        let selectedFile = null;
        let userPassword = '';

        passwordInput.addEventListener('input', (e) => {
            userPassword = e.target.value;
            checkPasswordStrength(userPassword);
            updateEncryptButton();
        });

        fileInput.addEventListener('change', (e) => {
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );
            
            return {
                encrypted: new Uint8Array(encrypted),
                iv: iv,
                salt: salt
            };
        }

        // ===== CAMADA 5: Rede Feistel 8 rounds =====
        function applyFeistelNetwork(data, seed, rounds) {
            const result = new Uint8Array(data.length);
            const blockSize = 16;
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const encrypted = feistelBlock(block, seed, rounds);
                result.set(encrypted, i);
            }
            
            return result;
        }

        function feistelBlock(block, seed, rounds) {
            if (block.length < 2) return block;
            
            const mid = Math.floor(block.length / 2);
            let left = block.slice(0, mid);
            let right = block.slice(mid);
            
            for (let round = 0; round < rounds; round++) {
                const roundKey = generateRoundKey(seed, round);
                const fOutput = feistelFunction(right, roundKey);
                const temp = new Uint8Array(left.length);
                
                for (let i = 0; i < left.length; i++) {
                    temp[i] = left[i] ^ fOutput[i % fOutput.length];
                }
                
                left = right;
                right = temp;
            }
            
            const result = new Uint8Array(block.length);
            result.set(left, 0);
            result.set(right, left.length);
            return result;
        }

        function feistelFunction(data, key) {
            const result = new Uint8Array(data.length);
            
            for (let i = 0; i < data.length; i++) {
                const mixed = data[i] ^ key[i % key.length];
                result[i] = ((mixed << 3) | (mixed >> 5)) & 0xFF;
            }
            
            return result;
        }

        function generateRoundKey(seed, round) {
            const key = new Uint8Array(16);
            let hash = simpleHash(seed + round.toString());
            
            for (let i = 0; i < 16; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                key[i] = (hash >> (i * 2)) & 0xFF;
            }
            
            return key;
        }

        // ===== CAMADA 6: Bit-Shifting Metam√≥rfico Avan√ßado =====
        function applyAdvancedMetamorphicShift(data, seed) {
            const result = new Uint8Array(data.length);
            let hash1 = simpleHash(seed);
            let hash2 = simpleHash(seed + 'meta');
            
            for (let i = 0; i < data.length; i++) {
                hash1 = ((hash1 * 1103515245) + 12345) & 0x7fffffff;
                hash2 = ((hash2 * 69069) + 1) & 0x7fffffff;
                
                const shift1 = (hash1 % 5) + 1;
                const shift2 = (hash2 % 3) + 1;
                
                const rotated1 = ((data[i] << shift1) | (data[i] >> (8 - shift1))) & 0xFF;
                const rotated2 = ((rotated1 >> shift2) | (rotated1 << (8 - shift2))) & 0xFF;
                
                result[i] = rotated2;
            }
            
            return result;
        }

        // ===== CAMADA 7: Code Morphing Avan√ßado =====
        function applyAdvancedCodeMorphing(data, seed) {
            const result = new Uint8Array(data.length);
            const morphMap = generateAdvancedMorphMap(seed);
            
            for (let i = 0; i < data.length; i++) {
                const pattern1 = (data[i] << 8) | (data[(i + 1) % data.length]);
                const pattern2 = (data[(i + 2) % data.length] << 8) | (data[(i + 3) % data.length]);
                
                const morphed = morphComplexPattern(pattern1, pattern2, morphMap);
                result[i] = (morphed >> 8) & 0xFF;
            }
            
            return result;
        }

        function generateAdvancedMorphMap(seed) {
            let hash = simpleHash(seed);
            const map = [];
            
            for (let i = 0; i < 512; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                map[i] = hash & 0xFFFF;
            }
            
            return map;
        }

        function morphComplexPattern(p1, p2, map) {
            const idx1 = p1 & 0x1FF;
            const idx2 = p2 & 0x1FF;
            return ((p1 ^ map[idx1]) + (p2 ^ map[idx2])) & 0xFFFF;
        }

        // ===== CAMADA 8: ChaCha20 Simulado =====
        async function simulateChaCha20(data, password) {
            const nonce = crypto.getRandomValues(new Uint8Array(12));
            const key = await deriveKey256(password, 'chacha20');
            
            const result = new Uint8Array(data.length);
            let counter = 0;
            
            for (let i = 0; i < data.length; i += 64) {
                const keystream = chachaBlock(key, nonce, counter++);
                
                for (let j = 0; j < 64 && i + j < data.length; j++) {
                    result[i + j] = data[i + j] ^ keystream[j];
                }
            }
            
            return { encrypted: result, nonce };
        }

        function chachaBlock(key, nonce, counter) {
            const state = new Uint32Array(16);
            
            // Constants "expand 32-byte k"
            state[0] = 0x61707865;
            state[1] = 0x3320646e;
            state[2] = 0x79622d32;
            state[3] = 0x6b206574;
            
            // Key (8 words)
            for (let i = 0; i < 8; i++) {
                state[4 + i] = (key[i * 4] | (key[i * 4 + 1] << 8) | 
                               (key[i * 4 + 2] << 16) | (key[i * 4 + 3] << 24)) >>> 0;
            }
            
            // Counter
            state[12] = counter;
            
            // Nonce (3 words)
            for (let i = 0; i < 3; i++) {
                state[13 + i] = (nonce[i * 4] | (nonce[i * 4 + 1] << 8) | 
                                (nonce[i * 4 + 2] << 16) | (nonce[i * 4 + 3] << 24)) >>> 0;
            }
            
            const working = new Uint32Array(state);
            
            // 20 rounds (10 double rounds)
            for (let i = 0; i < 10; i++) {
                quarterRound(working, 0, 4, 8, 12);
                quarterRound(working, 1, 5, 9, 13);
                quarterRound(working, 2, 6, 10, 14);
                quarterRound(working, 3, 7, 11, 15);
                quarterRound(working, 0, 5, 10, 15);
                quarterRound(working, 1, 6, 11, 12);
                quarterRound(working, 2, 7, 8, 13);
                quarterRound(working, 3, 4, 9, 14);
            }
            
            for (let i = 0; i < 16; i++) {
                working[i] = (working[i] + state[i]) >>> 0;
            }
            
            const output = new Uint8Array(64);
            for (let i = 0; i < 16; i++) {
                output[i * 4] = working[i] & 0xFF;
                output[i * 4 + 1] = (working[i] >> 8) & 0xFF;
                output[i * 4 + 2] = (working[i] >> 16) & 0xFF;
                output[i * 4 + 3] = (working[i] >> 24) & 0xFF;
            }
            
            return output;
        }

        function quarterRound(state, a, b, c, d) {
            state[a] = (state[a] + state[b]) >>> 0;
            state[d] ^= state[a];
            state[d] = ((state[d] << 16) | (state[d] >>> 16)) >>> 0;
            
            state[c] = (state[c] + state[d]) >>> 0;
            state[b] ^= state[c];
            state[b] = ((state[b] << 12) | (state[b] >>> 20)) >>> 0;
            
            state[a] = (state[a] + state[b]) >>> 0;
            state[d] ^= state[a];
            state[d] = ((state[d] << 8) | (state[d] >>> 24)) >>> 0;
            
            state[c] = (state[c] + state[d]) >>> 0;
            state[b] ^= state[c];
            state[b] = ((state[b] << 7) | (state[b] >>> 25)) >>> 0;
        }

        // ===== CAMADA 9: Serpent-256 Simulado =====
        async function simulateSerpent256(data, password) {
            const key = await deriveKey256(password, 'serpent');
            const result = new Uint8Array(data.length);
            const blockSize = 16;
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const encrypted = serpentBlock(block, key);
                result.set(encrypted, i);
            }
            
            return result;
        }

        function serpentBlock(block, key) {
            const state = new Uint32Array(4);
            
            for (let i = 0; i < Math.min(block.length, 16); i++) {
                const idx = i >> 2;
                const shift = (i & 3) << 3;
                state[idx] |= block[i] << shift;
            }
            
            // 32 rounds simplificados
            for (let round = 0; round < 32; round++) {
                const roundKey = new Uint32Array(4);
                for (let i = 0; i < 4; i++) {
                    roundKey[i] = ((key[i * 8 + (round % 8)] << 24) | 
                                   (key[i * 8 + ((round + 1) % 8)] << 16) |
                                   (key[i * 8 + ((round + 2) % 8)] << 8) | 
                                   key[i * 8 + ((round + 3) % 8)]) >>> 0;
                }
                
                for (let i = 0; i < 4; i++) {
                    state[i] ^= roundKey[i];
                }
                
                serpentSBox(state, round % 8);
                serpentLinearTransform(state);
            }
            
            const output = new Uint8Array(block.length);
            for (let i = 0; i < Math.min(block.length, 16); i++) {
                const idx = i >> 2;
                const shift = (i & 3) << 3;
                output[i] = (state[idx] >> shift) & 0xFF;
            }
            
            return output;
        }

        function serpentSBox(state, sboxNum) {
            for (let i = 0; i < 4; i++) {
                const x = state[i];
                state[i] = serpentSBoxSingle(x, sboxNum);
            }
        }

        function serpentSBoxSingle(x, sboxNum) {
            const nibbles = [
                (x & 0xF), ((x >> 4) & 0xF), ((x >> 8) & 0xF), ((x >> 12) & 0xF),
                ((x >> 16) & 0xF), ((x >> 20) & 0xF), ((x >> 24) & 0xF), ((x >> 28) & 0xF)
            ];
            
            const sboxTables = [
                [3,8,15,1,10,6,5,11,14,13,4,2,7,0,9,12],
                [15,12,2,7,9,0,5,10,1,11,14,8,6,13,3,4],
                [8,6,7,9,3,12,10,15,13,1,14,4,0,11,5,2],
                [0,15,11,8,12,9,6,3,13,1,2,4,10,7,5,14]
            ];
            
            const table = sboxTables[sboxNum % 4];
            
            for (let i = 0; i < 8; i++) {
                nibbles[i] = table[nibbles[i]];
            }
            
            return (nibbles[0] | (nibbles[1] << 4) | (nibbles[2] << 8) | (nibbles[3] << 12) |
                   (nibbles[4] << 16) | (nibbles[5] << 20) | (nibbles[6] << 24) | (nibbles[7] << 28)) >>> 0;
        }

        function serpentLinearTransform(state) {
            const x0 = state[0], x1 = state[1], x2 = state[2], x3 = state[3];
            
            state[0] = ((x0 << 13) | (x0 >>> 19)) >>> 0;
            state[2] = ((x2 << 3) | (x2 >>> 29)) >>> 0;
            state[1] = (x1 ^ state[0] ^ state[2]) >>> 0;
            state[3] = (x3 ^ state[2] ^ (state[0] << 3)) >>> 0;
            state[1] = ((state[1] << 1) | (state[1] >>> 31)) >>> 0;
            state[3] = ((state[3] << 7) | (state[3] >>> 25)) >>> 0;
            state[0] = (state[0] ^ state[1] ^ state[3]) >>> 0;
            state[2] = (state[2] ^ state[3] ^ (state[1] << 7)) >>> 0;
            state[0] = ((state[0] << 5) | (state[0] >>> 27)) >>> 0;
            state[2] = ((state[2] << 22) | (state[2] >>> 10)) >>> 0;
        }

        // ===== CAMADA 10: Twofish-256 Simulado =====
        async function simulateTwofish256(data, password) {
            const key = await deriveKey256(password, 'twofish');
            const result = new Uint8Array(data.length);
            const blockSize = 16;
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const encrypted = twofishBlock(block, key);
                result.set(encrypted, i);
            }
            
            return result;
        }

        function twofishBlock(block, key) {
            const state = new Uint32Array(4);
            
            for (let i = 0; i < Math.min(block.length, 16); i++) {
                const idx = i >> 2;
                const shift = (i & 3) << 3;
                state[idx] |= block[i] << shift;
            }
            
            // 16 rounds
            for (let round = 0; round < 16; round++) {
                const k0 = ((key[(round * 4) % 32] << 24) | (key[(round * 4 + 1) % 32] << 16) |
                           (key[(round * 4 + 2) % 32] << 8) | key[(round * 4 + 3) % 32]) >>> 0;
                const k1 = ((key[(round * 4 + 4) % 32] << 24) | (key[(round * 4 + 5) % 32] << 16) |
                           (key[(round * 4 + 6) % 32] << 8) | key[(round * 4 + 7) % 32]) >>> 0;
                
                const F0 = twofishF(state[0], k0);
                const F1 = twofishF(((state[1] << 8) | (state[1] >>> 24)) >>> 0, k1);
                
                state[2] ^= (F0 + F1 + k0) >>> 0;
                state[2] = ((state[2] >>> 1) | (state[2] << 31)) >>> 0;
                state[3] = ((state[3] << 1) | (state[3] >>> 31)) >>> 0;
                state[3] ^= (F0 + 2 * F1 + k1) >>> 0;
                
                [state[0], state[1], state[2], state[3]] = [state[2], state[3], state[0], state[1]];
            }
            
            const output = new Uint8Array(block.length);
            for (let i = 0; i < Math.min(block.length, 16); i++) {
                const idx = i >> 2;
                const shift = (i & 3) << 3;
                output[i] = (state[idx] >> shift) & 0xFF;
            }
            
            return output;
        }

        function twofishF(x, k) {
            const q0 = [(x & 0xFF), ((x >> 8) & 0xFF), ((x >> 16) & 0xFF), ((x >> 24) & 0xFF)];
            
            for (let i = 0; i < 4; i++) {
                q0[i] = ((q0[i] ^ ((k >> (i * 8)) & 0xFF)) * 0x1B) & 0xFF;
            }
            
            return (q0[0] | (q0[1] << 8) | (q0[2] << 16) | (q0[3] << 24)) >>> 0;
        }

        // ===== CAMADA 11: DNA Encoding =====
        function applyDNAEncoding(data, seed) {
            const dnaMap = generateDNAMap(seed);
            const encoded = [];
            
            for (let i = 0; i < data.length; i++) {
                const byte = data[i];
                const nib1 = (byte >> 4) & 0x0F;
                const nib2 = byte & 0x0F;
                
                encoded.push(dnaMap[nib1]);
                encoded.push(dnaMap[nib2]);
            }
            
            return dnaToBytes(encoded);
        }

        function generateDNAMap(seed) {
            const bases = ['A', 'C', 'T', 'G'];
            const map = {};
            let hash = simpleHash(seed);
            
            for (let i = 0; i < 16; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const b1 = bases[hash % 4];
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const b2 = bases[hash % 4];
                map[i] = b1 + b2;
            }
            
            return map;
        }

        function dnaToBytes(dnaArray) {
            const baseValues = { 'A': 0, 'C': 1, 'T': 2, 'G': 3 };
            const result = new Uint8Array(Math.ceil(dnaArray.length / 4));
            
            for (let i = 0; i < dnaArray.length; i++) {
                const pair = dnaArray[i];
                const val = (baseValues[pair[0]] << 2) | baseValues[pair[1]];
                const byteIdx = Math.floor(i / 4);
                const shift = (i % 4) * 2;
                result[byteIdx] |= (val << shift);
            }
            
            return result;
        }

        // ===== CAMADA 12: Lattice-Based Obfuscation =====
        function applyLatticeObfuscation(data, seed) {
            const dimension = 8;
            const lattice = generateLattice(dimension, seed);
            const result = new Uint8Array(data.length);
            
            for (let i = 0; i < data.length; i++) {
                const vector = [(data[i] >> 4) & 0x0F, data[i] & 0x0F];
                const obfuscated = latticeMult(vector, lattice);
                result[i] = ((obfuscated[0] & 0x0F) << 4) | (obfuscated[1] & 0x0F);
            }
            
            return result;
        }

        function generateLattice(dim, seed) {
            const lattice = [];
            let hash = simpleHash(seed);
            
            for (let i = 0; i < dim; i++) {
                lattice[i] = [];
                for (let j = 0; j < dim; j++) {
                    hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                    lattice[i][j] = (hash % 16);
                }
            }
            
            return lattice;
        }

        function latticeMult(vector, lattice) {
            const result = [0, 0];
            
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < vector.length; j++) {
                    result[i] = (result[i] + vector[j] * lattice[i][j]) % 256;
                }
            }
            
            return result;
        }

        // ===== CAMADA 13: Cellular Automata (Rule 30) =====
        function applyCellularAutomata(data, seed, generations) {
            const result = new Uint8Array(data.length);
            
            for (let i = 0; i < data.length; i++) {
                result[i] = evolveByte(data[i], seed, generations);
            }
            
            return result;
        }

        function evolveByte(byte, seed, generations) {
            let cells = new Array(8);
            
            for (let i = 0; i < 8; i++) {
                cells[i] = (byte >> i) & 1;
            }
            
            let hash = simpleHash(seed);
            
            for (let gen = 0; gen < generations; gen++) {
                const newCells = new Array(8);
                
                for (let i = 0; i < 8; i++) {
                    const left = cells[(i - 1 + 8) % 8];
                    const center = cells[i];
                    const right = cells[(i + 1) % 8];
                    
                    hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                    const rule = (hash % 2 === 0) ? 30 : 110;
                    
                    const pattern = (left << 2) | (center << 1) | right;
                    newCells[i] = (rule >> pattern) & 1;
                }
                
                cells = newCells;
            }
            
            let result = 0;
            for (let i = 0; i < 8; i++) {
                result |= (cells[i] << i);
            }
            
            return result;
        }

        // ===== Fun√ß√µes Auxiliares =====
        async function deriveKey256(password, context) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password + context);
            
            try {
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                return new Uint8Array(hashBuffer);
            } catch (e) {
                const key = new Uint8Array(32);
                let hash = simpleHash(password + context);
                
                for (let i = 0; i < 32; i++) {
                    hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                    key[i] = (hash >> (i % 8)) & 0xFF;
                }
                
                return key;
            }
        }

        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & 0x7fffffff;
            }
            return Math.abs(hash);
        }

        async function generateIntegrityHash(data) {
            try {
                const hashBuffer = await crypto.subtle.digest('SHA-512', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (e) {
                let h0 = 0x6a09e667, h1 = 0xbb67ae85;
                let h2 = 0x3c6ef372, h3 = 0xa54ff53a;
                let h4 = 0x510e527f, h5 = 0x9b05688c;
                
                const chunkSize = 128;
                for (let i = 0; i < data.length; i += chunkSize) {
                    const chunk = data.slice(i, i + chunkSize);
                    
                    for (let j = 0; j < chunk.length; j++) {
                        h0 = ((h0 << 5) - h0) + chunk[j];
                        h1 = ((h1 << 7) - h1) ^ chunk[j];
                        h2 = ((h2 << 9) - h2) + (chunk[j] * 31);
                        h3 = ((h3 << 11) - h3) ^ (chunk[j] * 17);
                        h4 = ((h4 << 13) - h4) + (chunk[j] * 23);
                        h5 = ((h5 << 15) - h5) ^ (chunk[j] * 29);
                    }
                    
                    h0 = h0 & 0xffffffff;
                    h1 = h1 & 0xffffffff;
                    h2 = h2 & 0xffffffff;
                    h3 = h3 & 0xffffffff;
                    h4 = h4 & 0xffffffff;
                    h5 = h5 & 0xffffffff;
                }
                
                return (Math.abs(h0).toString(16).padStart(8, '0') +
                        Math.abs(h1).toString(16).padStart(8, '0') +
                        Math.abs(h2).toString(16).padStart(8, '0') +
                        Math.abs(h3).toString(16).padStart(8, '0') +
                        Math.abs(h4).toString(16).padStart(8, '0') +
                        Math.abs(h5).toString(16).padStart(8, '0'));
            }
        }

        function downloadFile(data, originalName, hash) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const nameParts = originalName.split('.');
            const ext = nameParts.pop();
            const baseName = nameParts.join('.');
            
            a.href = url;
            a.download = `${baseName}_quasar.${ext}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Hash SHA3-512:', hash);
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function resetInterface() {
            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
            status.style.display = 'none';
            fileName.style.display = 'none';
            fileInput.value = '';
            selectedFile = null;
            passwordInput.value = '';
            userPassword = '';
            passwordStrength.textContent = '';
            encryptBtn.disabled = true;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        console.log('‚ö° QuasarProtect Advanced iniciado');
        console.log('üõ°Ô∏è 15 camadas de prote√ß√£o ativas');
        console.log('üîê AES-256 + ChaCha20 + Serpent-256 + Twofish-256');
        console.log('üß¨ DNA Encoding + Lattice + Cellular Automata');
        console.log('üîÑ Polimorfismo + Metamorfismo + Ofusca√ß√£o Avan√ßada'); file = e.target.files[0];
            if (file) {
                selectedFile = file;
                fileName.textContent = `üìÑ ${file.name} (${formatFileSize(file.size)})`;
                fileName.style.display = 'block';
                updateEncryptButton();
            }
        });

        function updateEncryptButton() {
            encryptBtn.disabled = !(selectedFile && userPassword.length >= 12);
        }

        function checkPasswordStrength(password) {
            if (password.length === 0) {
                passwordStrength.textContent = '';
                return;
            }

            let strength = 0;

            if (password.length >= 12) strength++;
            if (password.length >= 16) strength++;
            if (password.length >= 20) strength++;
            if (/[a-z]/.test(password)) strength++;
            if (/[A-Z]/.test(password)) strength++;
            if (/[0-9]/.test(password)) strength++;
            if (/[^a-zA-Z0-9]/.test(password)) strength++;

            if (strength <= 3) {
                passwordStrength.style.color = '#dc2626';
                passwordStrength.textContent = '‚ùå Senha fraca - Adicione mais caracteres, n√∫meros e s√≠mbolos';
            } else if (strength <= 5) {
                passwordStrength.style.color = '#f59e0b';
                passwordStrength.textContent = '‚ö†Ô∏è Senha m√©dia - Recomendado 16+ caracteres';
            } else {
                passwordStrength.style.color = '#059669';
                passwordStrength.textContent = '‚úÖ Senha forte - Pronta para prote√ß√£o m√°xima';
            }
        }

        encryptBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            encryptBtn.disabled = true;
            progressBar.style.display = 'block';
            showStatus('‚ö° Aplicando 15 camadas de prote√ß√£o QuasarProtect...', 'info');

            try {
                await processFile(selectedFile);
            } catch (error) {
                showStatus('Erro: ' + error.message, 'error');
                encryptBtn.disabled = false;
                console.error(error);
            }
        });

        async function processFile(file) {
            updateProgress(5);
            
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            if (fileExt === 'apk' || fileExt === 'zip') {
                await processArchive(file);
            } else {
                await processRegularFile(file);
            }
        }

        async function processRegularFile(file) {
            updateProgress(20);
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            updateProgress(40);
            
            const encrypted = await applyAdvancedEncryption(uint8Array, file.name);
            
            updateProgress(90);
            
            const hash = await generateIntegrityHash(encrypted);
            downloadFile(encrypted, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ Arquivo protegido com 15 camadas! Hash: ' + hash.substring(0, 16) + '...', 'success');
            
            setTimeout(() => resetInterface(), 4000);
        }

        async function processArchive(file) {
            updateProgress(15);
            
            const zip = new JSZip();
            const content = await file.arrayBuffer();
            await zip.loadAsync(content);
            
            updateProgress(25);

            let fileCount = 0;
            const totalFiles = Object.keys(zip.files).length;
            
            const safeToEncrypt = [
                'assets/',
                'res/raw/',
                'res/drawable',
                'res/values',
                'lib/',
                'resources/',
                'META-INF/services/'
            ];

            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                fileCount++;
                const progress = 25 + (fileCount / totalFiles) * 50;
                updateProgress(progress);

                try {
                    const isSafe = safeToEncrypt.some(prefix => path.startsWith(prefix));
                    
                    if (isSafe) {
                        const data = await zipEntry.async('uint8array');
                        const encrypted = await applyAdvancedEncryption(data, path + file.name);
                        
                        zip.file(path, encrypted, {
                            binary: true,
                            compression: zipEntry.compression || 'DEFLATE'
                        });
                    }
                } catch (e) {
                    console.log('Mantendo arquivo original:', path);
                }
            }

            updateProgress(80);

            const newContent = await zip.generateAsync({
                type: 'uint8array',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 },
                platform: 'UNIX'
            });

            updateProgress(95);

            const hash = await generateIntegrityHash(newContent);
            downloadFile(newContent, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ APK/ZIP protegido com 15 camadas! Hash: ' + hash.substring(0, 16) + '...', 'success');
            
            setTimeout(() => resetInterface(), 5000);
        }

        async function applyAdvancedEncryption(data, seed) {
            // ===== CAMADA 1: XOR Polim√≥rfico Multin√≠vel =====
            const layer1 = applyPolymorphicXOR(data, seed);
            
            // ===== CAMADA 2: Transposi√ß√£o de Blocos com Permuta√ß√£o Din√¢mica =====
            const layer2 = applyBlockTransposition(layer1, seed);
            
            // ===== CAMADA 3: S-Box Din√¢mica Multi-Round =====
            const layer3 = applyMultiRoundSBox(layer2, seed, 3);
            
            // ===== CAMADA 4: AES-256-GCM =====
            const { encrypted: layer4, iv: iv1, salt: salt1 } = await encryptAES256GCM(layer3, userPassword);
            
            // ===== CAMADA 5: Rede Feistel 8 rounds =====
            const layer5 = applyFeistelNetwork(layer4, seed, 8);
            
            // ===== CAMADA 6: Bit-Shifting Metam√≥rfico Avan√ßado =====
            const layer6 = applyAdvancedMetamorphicShift(layer5, seed);
            
            // ===== CAMADA 7: Code Morphing Multi-Padr√£o =====
            const layer7 = applyAdvancedCodeMorphing(layer6, seed);
            
            // ===== CAMADA 8: ChaCha20-Poly1305 Simulado =====
            const { encrypted: layer8, nonce } = await simulateChaCha20(layer7, userPassword);
            
            // ===== CAMADA 9: Serpent-256 Simulado =====
            const layer9 = await simulateSerpent256(layer8, seed + userPassword);
            
            // ===== CAMADA 10: Twofish-256 Simulado =====
            const layer10 = await simulateTwofish256(layer9, seed + userPassword + '2');
            
            // ===== CAMADA 11: DNA Encoding =====
            const layer11 = applyDNAEncoding(layer10, seed);
            
            // ===== CAMADA 12: Lattice-Based Obfuscation =====
            const layer12 = applyLatticeObfuscation(layer11, seed);
            
            // ===== CAMADA 13: Cellular Automata Cipher (Rule 30) =====
            const layer13 = applyCellularAutomata(layer12, seed, 10);
            
            // Estrutura final: [marcador][salt][iv][nonce][dados multicamadas]
            const marker = new TextEncoder().encode('QPAV');
            const finalResult = new Uint8Array(
                marker.length + salt1.length + iv1.length + nonce.length + layer13.length
            );
            
            let offset = 0;
            finalResult.set(marker, offset); offset += marker.length;
            finalResult.set(salt1, offset); offset += salt1.length;
            finalResult.set(iv1, offset); offset += iv1.length;
            finalResult.set(nonce, offset); offset += nonce.length;
            finalResult.set(layer13, offset);
            
            return finalResult;
        }

        // ===== CAMADA 1: XOR Polim√≥rfico Avan√ßado =====
        function applyPolymorphicXOR(data, seed) {
            const result = new Uint8Array(data.length);
            const keyStream = generateAdvancedKeyStream(seed, data.length);
            
            for (let i = 0; i < data.length; i++) {
                const key1 = keyStream[i];
                const key2 = keyStream[(i * 3) % keyStream.length];
                const key3 = keyStream[(i * 7) % keyStream.length];
                result[i] = data[i] ^ key1 ^ key2 ^ key3;
            }
            
            return result;
        }

        function generateAdvancedKeyStream(seed, length) {
            const stream = new Uint8Array(length);
            let hash1 = simpleHash(seed);
            let hash2 = simpleHash(seed + 'alt');
            
            for (let i = 0; i < length; i++) {
                hash1 = ((hash1 * 1103515245) + 12345) & 0x7fffffff;
                hash2 = ((hash2 * 69069) + 1) & 0x7fffffff;
                stream[i] = ((hash1 >> 16) ^ (hash2 >> 8)) & 0xFF;
            }
            
            return stream;
        }

        // ===== CAMADA 2: Transposi√ß√£o Avan√ßada =====
        function applyBlockTransposition(data, seed) {
            const blockSize = 32;
            const result = new Uint8Array(data.length);
            const permutation = generatePermutation(blockSize, seed);
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const transposed = new Uint8Array(block.length);
                
                for (let j = 0; j < block.length; j++) {
                    const newPos = permutation[j % permutation.length] % block.length;
                    transposed[newPos] = block[j];
                }
                
                result.set(transposed, i);
            }
            
            return result;
        }

        function generatePermutation(size, seed) {
            const perm = Array.from({length: size}, (_, i) => i);
            let hash = simpleHash(seed);
            
            for (let i = size - 1; i > 0; i--) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const j = hash % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }
            
            return perm;
        }

        // ===== CAMADA 3: S-Box Multi-Round =====
        function applyMultiRoundSBox(data, seed, rounds) {
            let result = new Uint8Array(data);
            
            for (let round = 0; round < rounds; round++) {
                const sbox = generateDynamicSBox(seed + round.toString());
                const temp = new Uint8Array(result.length);
                
                for (let i = 0; i < result.length; i++) {
                    temp[i] = sbox[result[i]];
                }
                
                result = temp;
            }
            
            return result;
        }

        function generateDynamicSBox(seed) {
            const sbox = Array.from({length: 256}, (_, i) => i);
            let hash = simpleHash(seed);
            
            for (let i = 255; i > 0; i--) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const j = hash % (i + 1);
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }

        // ===== CAMADA 4: AES-256-GCM =====
        async function encryptAES256GCM(data, password) {
            const salt = crypto.getRandomValues(new Uint8Array(32));
            
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            
            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 200000,
                    hash: 'SHA-512'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
            
            const