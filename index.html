<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuasarProtect - Criptografia Multin√≠vel Avan√ßada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 50%, #450a0a 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.98);
            border-radius: 20px;
            padding: 35px;
            box-shadow: 0 25px 70px rgba(220, 38, 38, 0.4);
            max-width: 650px;
            width: 100%;
            border: 3px solid #dc2626;
        }

        h1 {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            margin-bottom: 10px;
            font-size: 32px;
            font-weight: 900;
            letter-spacing: -1px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 25px;
            font-weight: 500;
        }

        .security-badge {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            padding: 18px;
            border-radius: 12px;
            text-align: center;
            margin-bottom: 25px;
            font-size: 14px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(220, 38, 38, 0.3);
        }

        .security-badge small {
            font-size: 11px;
            opacity: 0.95;
        }

        .layers-list {
            background: #fef2f2;
            border-left: 4px solid #dc2626;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            font-size: 12px;
        }

        .layers-list h4 {
            color: #991b1b;
            margin-bottom: 10px;
            font-size: 13px;
        }

        .layers-list ul {
            list-style: none;
            padding-left: 0;
        }

        .layers-list li {
            padding: 5px 0;
            color: #444;
        }

        .layers-list li:before {
            content: "‚ö° ";
            color: #dc2626;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .file-input-label {
            display: block;
            padding: 25px;
            background: #fef2f2;
            border: 3px dashed #dc2626;
            border-radius: 12px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 600;
            color: #991b1b;
        }

        .file-input-label:hover {
            background: #fee2e2;
            border-color: #991b1b;
            transform: translateY(-2px);
        }

        #fileInput {
            display: none;
        }

        .file-name {
            margin-top: 12px;
            padding: 12px;
            background: #fee2e2;
            border-radius: 10px;
            font-size: 14px;
            word-break: break-all;
            display: none;
            color: #991b1b;
            font-weight: 600;
            border: 2px solid #fca5a5;
        }

        .btn {
            width: 100%;
            padding: 18px;
            border: none;
            border-radius: 12px;
            font-size: 17px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .btn-encrypt {
            background: linear-gradient(135deg, #dc2626 0%, #991b1b 100%);
            color: white;
            box-shadow: 0 6px 20px rgba(220, 38, 38, 0.4);
        }

        .btn-encrypt:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(220, 38, 38, 0.5);
        }

        .btn-encrypt:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #fef2f2;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
            border: 2px solid #fca5a5;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #dc2626 0%, #991b1b 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .status {
            margin-top: 15px;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            font-weight: 600;
            display: none;
        }

        .status.info {
            background: #dbeafe;
            color: #1e40af;
            display: block;
        }

        .status.success {
            background: #d1fae5;
            color: #065f46;
            display: block;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
            display: block;
        }

        .warning-box {
            background: #fef2f2;
            border: 2px solid #dc2626;
            padding: 18px;
            border-radius: 10px;
            margin-top: 20px;
            font-size: 13px;
            color: #444;
        }

        .warning-box strong {
            color: #dc2626;
            font-size: 14px;
        }

        .tech-info {
            margin-top: 25px;
            padding: 20px;
            background: #f9fafb;
            border-radius: 10px;
            font-size: 12px;
            border: 2px solid #e5e7eb;
        }

        .tech-info h3 {
            color: #991b1b;
            margin-bottom: 12px;
            font-size: 14px;
        }

        .tech-info ul {
            list-style: none;
            padding-left: 0;
        }

        .tech-info li {
            padding: 6px 0;
            line-height: 1.5;
            color: #374151;
        }

        .tech-info li strong {
            color: #dc2626;
        }

        .password-wrapper {
            margin-bottom: 20px;
        }

        .password-wrapper label {
            display: block;
            margin-bottom: 8px;
            color: #991b1b;
            font-weight: bold;
            font-size: 14px;
        }

        .password-wrapper input {
            width: 100%;
            padding: 14px;
            border: 2px solid #dc2626;
            border-radius: 10px;
            font-size: 15px;
            transition: all 0.3s;
        }

        .password-wrapper input:focus {
            outline: none;
            border-color: #991b1b;
            box-shadow: 0 0 0 4px rgba(220, 38, 38, 0.1);
        }

        .password-strength {
            margin-top: 8px;
            font-size: 13px;
            color: #666;
            font-weight: 600;
        }

        .scan-status {
            margin-top: 15px;
            padding: 15px;
            background: #fef2f2;
            border-left: 4px solid #dc2626;
            border-radius: 8px;
            display: none;
            font-size: 13px;
        }

        .scan-status.scanning {
            display: block;
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .scan-status.clean {
            display: block;
            background: #d1fae5;
            border-color: #059669;
        }

        .scan-status.threat {
            display: block;
            background: #fee2e2;
            border-color: #dc2626;
        }

        .scan-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 8px;
        }

        .scan-spinner {
            width: 20px;
            height: 20px;
            border: 3px solid #e5e7eb;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° QuasarProtect</h1>
        <p class="subtitle">Sistema de Criptografia Multin√≠vel com Polimorfismo e Metamorfismo</p>

        <div class="security-badge">
            ‚úÖ 10 Camadas de Prote√ß√£o Ativas + Scan Antiv√≠rus<br>
            <small>AES-256-GCM | RC4 | Polimorfismo | Metamorfismo | Scan Time Protection</small>
        </div>

        <div class="layers-list">
            <h4>üõ°Ô∏è Camadas de Seguran√ßa Aplicadas:</h4>
            <ul>
                <li>Camada 0: Scan Antiv√≠rus Heur√≠stico (Pr√©-processamento)</li>
                <li>Camada 1: XOR Polim√≥rfico Multin√≠vel</li>
                <li>Camada 2: Transposi√ß√£o de Blocos com Chave</li>
                <li>Camada 3: S-Box Din√¢mica Revers√≠vel</li>
                <li>Camada 4: AES-256-GCM (N√≠vel Militar)</li>
                <li>Camada 5: Rede Feistel (4 rounds)</li>
                <li>Camada 6: Bit-Shifting Metam√≥rfico</li>
                <li>Camada 7: Code Morphing Revers√≠vel</li>
                <li>Camada 8: PBKDF2 (100k itera√ß√µes)</li>
                <li>Camada 9: SHA-512 Integrity Hash</li>
                <li>Camada 10: RC4 Stream Cipher (Camada Extra)</li>
            </ul>
        </div>

        <div class="password-wrapper">
            <label for="passwordInput">üîë Senha Mestra de Criptografia:</label>
            <input type="password" id="passwordInput" placeholder="Digite uma senha forte (m√≠nimo 8 caracteres)">
            <div id="passwordStrength" class="password-strength"></div>
        </div>

        <div class="file-input-wrapper">
            <label for="fileInput" class="file-input-label">
                üìÅ Selecionar Arquivo para Proteger<br>
                <small style="font-weight: normal; font-size: 11px;">(APK, PNG, JPG, PDF, ZIP, TXT)</small>
            </label>
            <input type="file" id="fileInput" accept=".apk,.png,.jpg,.jpeg,.pdf,.zip,.txt">
            <div id="fileName" class="file-name"></div>
        </div>

        <div id="scanStatus" class="scan-status">
            <strong>üõ°Ô∏è Scan Antiv√≠rus em Andamento...</strong>
            <div class="scan-progress">
                <div class="scan-spinner"></div>
                <span id="scanText">Analisando arquivo...</span>
            </div>
        </div>

        <button id="encryptBtn" class="btn btn-encrypt" disabled>
            üîí Aplicar Prote√ß√£o QuasarProtect (10 Camadas + RC4)
        </button>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="status" class="status"></div>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Importante - Leia Atentamente:</strong>
            <ul style="margin-top: 10px; padding-left: 20px; line-height: 1.8;">
                <li><strong>GUARDE SUA SENHA:</strong> Imposs√≠vel descriptografar sem ela</li>
                <li>APKs protegidos precisam de re-assinatura (APK Editor, MT Manager)</li>
                <li>9 camadas de prote√ß√£o tornam engenharia reversa extremamente dif√≠cil</li>
                <li>Processamento 100% local no navegador (nenhum dado enviado)</li>
            </ul>
        </div>

        <div class="tech-info">
            <h3>üî¨ Tecnologias de Prote√ß√£o Implementadas:</h3>
            <ul>
                <li><strong>Scan Antiv√≠rus Heur√≠stico:</strong> An√°lise de padr√µes, assinaturas e comportamento suspeito</li>
                <li><strong>RC4 Stream Cipher:</strong> Camada adicional de criptografia de fluxo</li>
                <li><strong>AES-256-GCM:</strong> Criptografia de n√≠vel militar aprovada pelo NIST</li>
                <li><strong>PBKDF2:</strong> Deriva√ß√£o de chave com 100.000 itera√ß√µes (SHA-512)</li>
                <li><strong>Polimorfismo:</strong> XOR multin√≠vel com chaves rotativas</li>
                <li><strong>Metamorfismo:</strong> Bit-shifting e code morphing din√¢micos</li>
                <li><strong>Ofusca√ß√£o:</strong> S-Box din√¢mica + Rede Feistel + Transposi√ß√£o</li>
                <li><strong>Autentica√ß√£o:</strong> GCM tag previne adultera√ß√£o</li>
                <li><strong>Integridade:</strong> SHA-512 hash final do arquivo completo</li>
            </ul>
            <p style="margin-top: 14px; font-size: 11px; color: #888; line-height: 1.6;">
                <strong>Nota T√©cnica:</strong> QuasarProtect combina t√©cnicas militares (AES-256-GCM) com
                camadas avan√ßadas de polimorfismo, metamorfismo e RC4, tornando a an√°lise est√°tica e
                engenharia reversa extremamente complexas. Todas as 10 camadas s√£o revers√≠veis
                usando a senha correta. O scan antiv√≠rus heur√≠stico previne processamento de arquivos
                potencialmente perigosos.
            </p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const passwordInput = document.getElementById('passwordInput');
        const passwordStrength = document.getElementById('passwordStrength');
        const encryptBtn = document.getElementById('encryptBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const status = document.getElementById('status');
        const scanStatus = document.getElementById('scanStatus');
        const scanText = document.getElementById('scanText');

        let selectedFile = null;
        let userPassword = '';
        let fileScanPassed = false;

        passwordInput.addEventListener('input', (e) => {
            userPassword = e.target.value;
            checkPasswordStrength(userPassword);
            updateEncryptButton();
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (file) {
                selectedFile = file;
                fileName.textContent = `üìÑ ${file.name} (${formatFileSize(file.size)})`;
                fileName.style.display = 'block';
                
                // Executar scan antiv√≠rus
                await performAntivirusScan(file);
            }
        });

        function updateEncryptButton() {
            encryptBtn.disabled = !(selectedFile && userPassword.length >= 8 && fileScanPassed);
        }

        // ===== SCAN ANTIV√çRUS HEUR√çSTICO =====
        async function performAntivirusScan(file) {
            fileScanPassed = false;
            scanStatus.className = 'scan-status scanning';
            scanText.textContent = 'Iniciando an√°lise heur√≠stica...';
            
            await sleep(500);
            
            try {
                // Fase 1: Verifica√ß√£o de tipo MIME
                scanText.textContent = 'Verificando tipo MIME e assinatura...';
                await sleep(300);
                
                const allowedMIMETypes = {
                    'apk': ['application/vnd.android.package-archive', 'application/zip', 'application/octet-stream'],
                    'zip': ['application/zip', 'application/x-zip-compressed', 'application/octet-stream'],
                    'png': ['image/png'],
                    'jpg': ['image/jpeg'],
                    'jpeg': ['image/jpeg'],
                    'pdf': ['application/pdf'],
                    'txt': ['text/plain']
                };
                
                const fileExt = file.name.split('.').pop().toLowerCase();
                const expectedMIMEs = allowedMIMETypes[fileExt];
                
                if (!expectedMIMEs) {
                    throw new Error(`Tipo de arquivo n√£o suportado: .${fileExt}`);
                }
                
                // Verificar se o MIME type corresponde √† extens√£o
                if (!expectedMIMEs.includes(file.type)) {
                    throw new Error(`MIME type incompat√≠vel: arquivo .${fileExt} tem MIME ${file.type}, esperado ${expectedMIMEs.join(' ou ')}`);
                }
                
                // Fase 2: Verifica√ß√£o de tamanho
                scanText.textContent = 'Analisando tamanho e estrutura...';
                await sleep(300);
                
                if (file.size > 500 * 1024 * 1024) { // 500MB
                    throw new Error('Arquivo muito grande - potencial risco de seguran√ßa');
                }
                
                if (file.size === 0) {
                    throw new Error('Arquivo vazio detectado');
                }
                
                // Fase 3: An√°lise de conte√∫do (primeiros bytes)
                scanText.textContent = 'Verificando magic bytes e assinaturas...';
                await sleep(400);
                
                const headerBytes = await file.slice(0, 512).arrayBuffer();
                const header = new Uint8Array(headerBytes);
                
                // Verificar magic bytes conhecidos
                const magicBytesValid = verifyMagicBytes(header, fileExt);
                
                if (!magicBytesValid.valid) {
                    throw new Error(`Assinatura de arquivo inv√°lida: esperado ${fileExt}, mas ${magicBytesValid.reason}`);
                }
                
                // Para arquivos TXT, validar que s√£o realmente texto
                if (fileExt === 'txt') {
                    const isValidText = await validateTextFile(file, header);
                    if (!isValidText.valid) {
                        throw new Error(`Arquivo .txt cont√©m dados bin√°rios ou inv√°lidos: ${isValidText.reason}`);
                    }
                }
                
                // Fase 4: Detec√ß√£o de padr√µes suspeitos no arquivo inteiro
                scanText.textContent = 'Procurando padr√µes maliciosos...';
                await sleep(400);
                
                const suspiciousResult = await checkSuspiciousPatternsFullFile(file);
                
                if (!suspiciousResult.safe) {
                    throw new Error(`Padr√µes maliciosos detectados: ${suspiciousResult.patterns.join(', ')}`);
                }
                
                // Fase 5: An√°lise de entropia em m√∫ltiplas amostras
                scanText.textContent = 'Calculando entropia de Shannon...';
                await sleep(300);
                
                const entropyResult = await analyzeFileEntropy(file);
                
                if (!entropyResult.safe) {
                    throw new Error(entropyResult.reason);
                }
                
                // Fase 6: Verifica√ß√£o final
                scanText.textContent = 'Finalizando an√°lise de seguran√ßa...';
                await sleep(400);
                
                // Scan completo - todas as verifica√ß√µes passaram
                fileScanPassed = true;
                scanStatus.className = 'scan-status clean';
                scanText.textContent = `‚úÖ Arquivo limpo! Nenhuma amea√ßa detectada (Valida√ß√£o completa do arquivo)`;
                
                updateEncryptButton();
                showStatus('Scan completo! Arquivo seguro. Digite sua senha mestra.', 'info');
                
            } catch (error) {
                fileScanPassed = false;
                scanStatus.className = 'scan-status threat';
                scanText.textContent = `‚ö†Ô∏è AMEA√áA DETECTADA: ${error.message}`;
                showStatus('Arquivo bloqueado por motivos de seguran√ßa!', 'error');
                
                selectedFile = null;
                fileInput.value = '';
                fileName.style.display = 'none';
                updateEncryptButton();
            }
        }

        function verifyMagicBytes(header, fileExt) {
            const magicBytes = {
                png: [0x89, 0x50, 0x4E, 0x47],
                jpg: [0xFF, 0xD8, 0xFF],
                jpeg: [0xFF, 0xD8, 0xFF],
                pdf: [0x25, 0x50, 0x44, 0x46],
                zip: [0x50, 0x4B, 0x03, 0x04],
                apk: [0x50, 0x4B, 0x03, 0x04] // APK √© um ZIP
            };
            
            const expectedBytes = magicBytes[fileExt];
            if (!expectedBytes) {
                // TXT n√£o tem magic bytes fixos, precisa valida√ß√£o separada
                return { valid: true, reason: 'Tipo de arquivo sem magic bytes definidos' };
            }
            
            for (let i = 0; i < expectedBytes.length; i++) {
                if (header[i] !== expectedBytes[i]) {
                    return { valid: false, reason: `magic bytes n√£o correspondem` };
                }
            }
            
            return { valid: true, reason: 'Magic bytes v√°lidos' };
        }

        async function validateTextFile(file, header) {
            try {
                // Verificar se cont√©m bytes de controle execut√°veis ou bin√°rios comuns
                const executableSignatures = [
                    [0x4D, 0x5A], // PE/EXE (MZ)
                    [0x7F, 0x45, 0x4C, 0x46], // ELF (Linux executables)
                    [0xCF, 0xFA, 0xED, 0xFE], // Mach-O (macOS executables)
                    [0x50, 0x4B], // ZIP/APK
                    [0x1F, 0x8B], // GZIP
                    [0x42, 0x4D], // BMP
                    [0xFF, 0xD8, 0xFF], // JPEG
                    [0x89, 0x50, 0x4E, 0x47] // PNG
                ];
                
                // Verificar se come√ßa com assinatura execut√°vel/bin√°ria
                for (const sig of executableSignatures) {
                    let matches = true;
                    for (let i = 0; i < sig.length; i++) {
                        if (header[i] !== sig[i]) {
                            matches = false;
                            break;
                        }
                    }
                    if (matches) {
                        return { valid: false, reason: 'arquivo cont√©m assinatura execut√°vel/bin√°ria no in√≠cio' };
                    }
                }
                
                // Limitar tamanho de arquivos TXT para prevenir bypass
                const maxTextSize = 10 * 1024 * 1024; // 10MB
                if (file.size > maxTextSize) {
                    return { valid: false, reason: `arquivo de texto muito grande (${(file.size / 1024 / 1024).toFixed(1)}MB). M√°ximo: ${maxTextSize / 1024 / 1024}MB` };
                }
                
                // Validar o arquivo inteiro em chunks com overlap para detectar padr√µes nas fronteiras
                const chunkSize = 8192;
                const overlapSize = 256; // Overlap para detectar padr√µes que cruzam fronteiras
                const totalChunks = Math.ceil(file.size / chunkSize);
                
                // Validar TODOS os chunks - sem exce√ß√£o
                const decoder = new TextDecoder('utf-8', { fatal: true });
                
                for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
                    const offset = Math.max(0, chunkIndex * chunkSize - (chunkIndex > 0 ? overlapSize : 0));
                    const endOffset = Math.min(file.size, (chunkIndex + 1) * chunkSize);
                    const size = endOffset - offset;
                    const chunkBytes = await file.slice(offset, offset + size).arrayBuffer();
                    const chunk = new Uint8Array(chunkBytes);
                    
                    // Verificar assinaturas execut√°veis em cada chunk (incluindo overlap)
                    for (const sig of executableSignatures) {
                        for (let i = 0; i <= chunk.length - sig.length; i++) {
                            let matches = true;
                            for (let j = 0; j < sig.length; j++) {
                                if (chunk[i + j] !== sig[j]) {
                                    matches = false;
                                    break;
                                }
                            }
                            if (matches) {
                                return { valid: false, reason: `assinatura execut√°vel encontrada no offset ${offset + i}` };
                            }
                        }
                    }
                    
                    // Tentar decodificar como UTF-8
                    try {
                        const text = decoder.decode(chunk);
                        
                        // Verificar se cont√©m caracteres de controle perigosos
                        let binaryCount = 0;
                        for (let i = 0; i < chunk.length; i++) {
                            const byte = chunk[i];
                            // Bytes de controle perigosos (exceto \n=10, \r=13, \t=9)
                            if (byte < 32 && byte !== 10 && byte !== 13 && byte !== 9) {
                                binaryCount++;
                            }
                            // NULL bytes s√£o muito suspeitos
                            if (byte === 0) {
                                binaryCount += 3;
                            }
                        }
                        
                        // Se mais de 5% s√£o bytes bin√°rios suspeitos, rejeitar
                        const binaryRatio = binaryCount / chunk.length;
                        if (binaryRatio > 0.05) {
                            return { valid: false, reason: `${(binaryRatio * 100).toFixed(1)}% de bytes bin√°rios no chunk ${chunkIndex}` };
                        }
                        
                    } catch (e) {
                        return { valid: false, reason: `chunk ${chunkIndex} n√£o √© UTF-8 v√°lido - poss√≠vel bin√°rio` };
                    }
                }
                
                return { valid: true, reason: 'arquivo de texto v√°lido (validado integralmente)' };
                
            } catch (error) {
                return { valid: false, reason: `erro na valida√ß√£o: ${error.message}` };
            }
        }

        async function checkSuspiciousPatternsFullFile(file) {
            const dangerous = [
                'eval(',
                '<script',
                'javascript:',
                'data:text/html',
                'vbscript:',
                'onload=',
                'onerror=',
                'onclick=',
                'onfocus=',
                '<iframe'
            ];
            
            // Limite de tamanho para verifica√ß√£o completa
            const maxScanSize = 50 * 1024 * 1024; // 50MB
            if (file.size > maxScanSize) {
                return {
                    safe: false,
                    patterns: [`Arquivo muito grande para scan completo (${(file.size / 1024 / 1024).toFixed(1)}MB > ${maxScanSize / 1024 / 1024}MB)`]
                };
            }
            
            const chunkSize = 16384; // 16KB chunks
            const overlapSize = 128; // Overlap para detectar padr√µes nas fronteiras
            const totalChunks = Math.ceil(file.size / chunkSize);
            const decoder = new TextDecoder('utf-8', { fatal: false });
            const foundPatterns = [];
            
            // Verificar TODOS os chunks sem exce√ß√£o (com overlap)
            for (let i = 0; i < totalChunks; i++) {
                const offset = Math.max(0, i * chunkSize - (i > 0 ? overlapSize : 0));
                const endOffset = Math.min(file.size, (i + 1) * chunkSize);
                const size = endOffset - offset;
                const chunkBytes = await file.slice(offset, offset + size).arrayBuffer();
                const chunk = new Uint8Array(chunkBytes);
                const text = decoder.decode(chunk).toLowerCase();
                
                for (const pattern of dangerous) {
                    if (text.includes(pattern.toLowerCase())) {
                        foundPatterns.push(`${pattern} (offset ${offset})`);
                        // Fail fast - n√£o precisa continuar
                        return {
                            safe: false,
                            patterns: foundPatterns
                        };
                    }
                }
            }
            
            return {
                safe: true,
                patterns: []
            };
        }

        async function analyzeFileEntropy(file) {
            // Limite de tamanho para an√°lise completa
            const maxAnalysisSize = 50 * 1024 * 1024; // 50MB
            if (file.size > maxAnalysisSize) {
                return {
                    safe: false,
                    reason: `Arquivo muito grande para an√°lise completa (${(file.size / 1024 / 1024).toFixed(1)}MB > ${maxAnalysisSize / 1024 / 1024}MB)`
                };
            }
            
            const sampleSize = 8192;
            const totalSamples = Math.ceil(file.size / sampleSize);
            
            // Analisar TODAS as amostras sem exce√ß√£o
            for (let i = 0; i < totalSamples; i++) {
                const offset = i * sampleSize;
                const size = Math.min(sampleSize, file.size - offset);
                const sampleBytes = await file.slice(offset, offset + size).arrayBuffer();
                const sample = new Uint8Array(sampleBytes);
                
                const entropy = calculateEntropy(sample);
                
                // Entropia muito alta em arquivos pequenos √© suspeita
                if (entropy > 7.9 && file.size < 1024) {
                    return {
                        safe: false,
                        reason: `Entropia anormalmente alta (${entropy.toFixed(2)}) no offset ${offset} - poss√≠vel arquivo criptografado ou malicioso`
                    };
                }
                
                // Avisar sobre entropia muito baixa
                if (entropy < 1.0 && file.size > 100) {
                    console.warn(`Entropia baixa (${entropy.toFixed(2)}) no offset ${offset}`);
                }
            }
            
            return { safe: true, reason: 'Entropia normal (valida√ß√£o completa)' };
        }

        function calculateEntropy(data) {
            const freq = new Array(256).fill(0);
            
            for (let i = 0; i < data.length; i++) {
                freq[data[i]]++;
            }
            
            let entropy = 0;
            const len = data.length;
            
            for (let i = 0; i < 256; i++) {
                if (freq[i] > 0) {
                    const p = freq[i] / len;
                    entropy -= p * Math.log2(p);
                }
            }
            
            return entropy;
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function checkPasswordStrength(password) {
            if (password.length === 0) {
                passwordStrength.textContent = '';
                return;
            }

            let strength = 0;

            if (password.length >= 8) strength++;
            if (password.length >= 12) strength++;
            if (/[a-z]/.test(password)) strength++;
            if (/[A-Z]/.test(password)) strength++;
            if (/[0-9]/.test(password)) strength++;
            if (/[^a-zA-Z0-9]/.test(password)) strength++;

            if (strength <= 2) {
                passwordStrength.style.color = '#dc2626';
                passwordStrength.textContent = '‚ùå Senha fraca - Use letras, n√∫meros e s√≠mbolos';
            } else if (strength <= 4) {
                passwordStrength.style.color = '#f59e0b';
                passwordStrength.textContent = '‚ö†Ô∏è Senha m√©dia - Adicione mais caracteres';
            } else {
                passwordStrength.style.color = '#059669';
                passwordStrength.textContent = '‚úÖ Senha forte - Pronta para prote√ß√£o m√°xima';
            }
        }

        encryptBtn.addEventListener('click', async () => {
            if (!selectedFile || !fileScanPassed) return;

            encryptBtn.disabled = true;
            progressBar.style.display = 'block';
            showStatus('‚ö° Aplicando 10 camadas de prote√ß√£o QuasarProtect (incluindo RC4)...', 'info');

            try {
                await processFile(selectedFile);
            } catch (error) {
                showStatus('Erro: ' + error.message, 'error');
                encryptBtn.disabled = false;
                console.error(error);
            }
        });

        async function processFile(file) {
            updateProgress(5);
            
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            if (fileExt === 'apk' || fileExt === 'zip') {
                await processArchive(file);
            } else if (fileExt === 'txt') {
                await processTextFile(file);
            } else {
                await processImageOrPDF(file);
            }
        }

        async function processTextFile(file) {
            updateProgress(20);
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            updateProgress(40);
            
            // Aplicar todas as 9 camadas de prote√ß√£o
            const encrypted = await applyAdvancedEncryption(uint8Array, file.name);
            
            updateProgress(90);
            
            const hash = await generateIntegrityHash(encrypted);
            downloadFile(encrypted, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ Arquivo TXT protegido com 10 camadas + RC4! Hash: ' + hash.substring(0, 16) + '...', 'success');
            
            setTimeout(() => resetInterface(), 4000);
        }

        async function processArchive(file) {
            updateProgress(15);
            
            const zip = new JSZip();
            const content = await file.arrayBuffer();
            await zip.loadAsync(content);
            
            updateProgress(25);

            let fileCount = 0;
            const totalFiles = Object.keys(zip.files).length;
            
            const safeToEncrypt = [
                'assets/',
                'res/raw/',
                'res/drawable',
                'res/values',
                'lib/',
                'resources/',
                'META-INF/services/'
            ];

            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                fileCount++;
                const progress = 25 + (fileCount / totalFiles) * 50;
                updateProgress(progress);

                try {
                    const isSafe = safeToEncrypt.some(prefix => path.startsWith(prefix));
                    
                    if (isSafe) {
                        const data = await zipEntry.async('uint8array');
                        const encrypted = await applyAdvancedEncryption(data, path + file.name);
                        
                        zip.file(path, encrypted, {
                            binary: true,
                            compression: zipEntry.compression || 'DEFLATE'
                        });
                    }
                } catch (e) {
                    console.log('Mantendo arquivo original:', path);
                }
            }

            updateProgress(80);

            const newContent = await zip.generateAsync({
                type: 'uint8array',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 },
                platform: 'UNIX'
            });

            updateProgress(95);

            const hash = await generateIntegrityHash(newContent);
            downloadFile(newContent, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ APK/ZIP protegido com 10 camadas + RC4! Hash: ' + hash.substring(0, 16) + '...', 'success');
            
            setTimeout(() => resetInterface(), 5000);
        }

        async function processImageOrPDF(file) {
            updateProgress(25);
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            let preserveStart = 0;
            let preserveEnd = 0;
            
            switch(fileExt) {
                case 'png':
                    preserveStart = 33;
                    preserveEnd = 12;
                    break;
                case 'jpg':
                case 'jpeg':
                    preserveStart = 20;
                    preserveEnd = 2;
                    break;
                case 'pdf':
                    preserveStart = 10;
                    preserveEnd = 20;
                    break;
            }

            updateProgress(45);

            const header = uint8Array.slice(0, preserveStart);
            const footer = uint8Array.slice(-preserveEnd);
            const content = uint8Array.slice(preserveStart, uint8Array.length - preserveEnd);

            updateProgress(55);

            const encryptStart = Math.floor(content.length * 0.1);
            const encryptEnd = Math.floor(content.length * 0.9);
            const toEncrypt = content.slice(encryptStart, encryptEnd);
            const encrypted = await applyAdvancedEncryption(toEncrypt, file.name);

            updateProgress(75);

            // O arquivo criptografado √© maior devido aos metadados das 9 camadas
            const sizeDiff = encrypted.length - (encryptEnd - encryptStart);
            const finalArray = new Uint8Array(uint8Array.length + sizeDiff);
            
            let offset = 0;
            finalArray.set(header, offset);
            offset += header.length;
            
            finalArray.set(content.slice(0, encryptStart), offset);
            offset += encryptStart;
            
            finalArray.set(encrypted, offset);
            offset += encrypted.length;
            
            finalArray.set(content.slice(encryptEnd), offset);
            offset += (content.length - encryptEnd);
            
            finalArray.set(footer, offset);

            updateProgress(92);

            const hash = await generateIntegrityHash(finalArray);
            downloadFile(finalArray, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ Arquivo protegido com 10 camadas + RC4! Hash: ' + hash.substring(0, 16) + '...', 'success');
            
            setTimeout(() => resetInterface(), 4000);
        }

        async function applyAdvancedEncryption(data, seed) {
            // ===== CAMADA 1: XOR Polim√≥rfico Multin√≠vel (Revers√≠vel) =====
            const layer1 = applyPolymorphicXOR(data, seed);
            
            // ===== CAMADA 2: Transposi√ß√£o de Blocos com Chave (Revers√≠vel) =====
            const layer2 = applyBlockTransposition(layer1, seed);
            
            // ===== CAMADA 3: S-Box Din√¢mica (Revers√≠vel) =====
            const layer3 = applyDynamicSBox(layer2, seed);
            
            // ===== CAMADA 4: AES-256-GCM (Revers√≠vel) =====
            const { encrypted, iv, salt } = await encryptAES256GCM(layer3, userPassword);
            
            // ===== CAMADA 5: Rede Feistel 4 rounds (Revers√≠vel) =====
            const layer5 = applyFeistelNetwork(encrypted, seed, 4);
            
            // ===== CAMADA 6: Bit-Shifting Metam√≥rfico (Revers√≠vel) =====
            const layer6 = applyMetamorphicShift(layer5, seed);
            
            // ===== CAMADA 7: Code Morphing (Revers√≠vel) =====
            const layer7 = applyCodeMorphing(layer6, seed);
            
            // ===== CAMADA 10: RC4Drop Stream Cipher (Revers√≠vel por XOR novamente) =====
            const layer10 = applyRC4Drop(layer7, userPassword + seed, 3072);
            
            // Estrutura final: [marcador][salt][iv][dados multicamadas]
            const marker = new TextEncoder().encode('QPRT');
            const finalResult = new Uint8Array(marker.length + salt.length + iv.length + layer10.length);
            finalResult.set(marker, 0);
            finalResult.set(salt, marker.length);
            finalResult.set(iv, marker.length + salt.length);
            finalResult.set(layer10, marker.length + salt.length + iv.length);
            
            return finalResult;
        }

        // ===== CAMADA 10: RC4Drop Stream Cipher =====
        // RC4Drop √© mais seguro que RC4 padr√£o - descarta os primeiros N bytes do keystream
        function applyRC4Drop(data, password, dropBytes = 3072) {
            const key = stringToKey(password);
            const S = initRC4State(key);
            
            // Drop dos primeiros bytes (mitiga√ß√£o de fraqueza do RC4)
            for (let i = 0; i < dropBytes; i++) {
                generateRC4Byte(S);
            }
            
            // Criptografar dados
            const result = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ generateRC4Byte(S);
            }
            
            return result;
        }

        function stringToKey(str) {
            const encoder = new TextEncoder();
            const bytes = encoder.encode(str);
            const key = new Uint8Array(256);
            
            for (let i = 0; i < 256; i++) {
                key[i] = bytes[i % bytes.length];
            }
            
            return key;
        }

        function initRC4State(key) {
            const S = new Uint8Array(256);
            
            // KSA (Key Scheduling Algorithm)
            for (let i = 0; i < 256; i++) {
                S[i] = i;
            }
            
            let j = 0;
            for (let i = 0; i < 256; i++) {
                j = (j + S[i] + key[i % key.length]) % 256;
                [S[i], S[j]] = [S[j], S[i]];
            }
            
            // Retornar state com √≠ndices
            return { S, i: 0, j: 0 };
        }

        function generateRC4Byte(state) {
            // PRGA (Pseudo-Random Generation Algorithm)
            state.i = (state.i + 1) % 256;
            state.j = (state.j + state.S[state.i]) % 256;
            
            [state.S[state.i], state.S[state.j]] = [state.S[state.j], state.S[state.i]];
            
            const K = state.S[(state.S[state.i] + state.S[state.j]) % 256];
            return K;
        }

        // ===== CAMADA 1: XOR Polim√≥rfico Multin√≠vel (Revers√≠vel por XOR novamente) =====
        function applyPolymorphicXOR(data, seed) {
            const result = new Uint8Array(data.length);
            const keyStream = generateKeyStream(seed, data.length);
            
            for (let i = 0; i < data.length; i++) {
                result[i] = data[i] ^ keyStream[i];
            }
            
            return result;
        }

        function generateKeyStream(seed, length) {
            const stream = new Uint8Array(length);
            let hash = simpleHash(seed);
            
            for (let i = 0; i < length; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                stream[i] = (hash >> 16) & 0xFF;
            }
            
            return stream;
        }

        // ===== CAMADA 2: Transposi√ß√£o de Blocos (Revers√≠vel com permuta√ß√£o inversa) =====
        function applyBlockTransposition(data, seed) {
            const blockSize = 16;
            const result = new Uint8Array(data.length);
            const permutation = generatePermutation(blockSize, seed);
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const transposed = new Uint8Array(block.length);
                
                for (let j = 0; j < block.length; j++) {
                    const newPos = permutation[j % permutation.length] % block.length;
                    transposed[newPos] = block[j];
                }
                
                result.set(transposed, i);
            }
            
            return result;
        }

        function generatePermutation(size, seed) {
            const perm = Array.from({length: size}, (_, i) => i);
            let hash = simpleHash(seed);
            
            for (let i = size - 1; i > 0; i--) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const j = hash % (i + 1);
                [perm[i], perm[j]] = [perm[j], perm[i]];
            }
            
            return perm;
        }

        // ===== CAMADA 3: S-Box Din√¢mica (Revers√≠vel com inverse S-box) =====
        function applyDynamicSBox(data, seed) {
            const sbox = generateDynamicSBox(seed);
            const result = new Uint8Array(data.length);
            
            for (let i = 0; i < data.length; i++) {
                result[i] = sbox[data[i]];
            }
            
            return result;
        }

        function generateDynamicSBox(seed) {
            const sbox = Array.from({length: 256}, (_, i) => i);
            let hash = simpleHash(seed);
            
            for (let i = 255; i > 0; i--) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const j = hash % (i + 1);
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }

        // ===== CAMADA 4: AES-256-GCM j√° implementada =====
        async function encryptAES256GCM(data, password) {
            const salt = crypto.getRandomValues(new Uint8Array(32));
            
            const encoder = new TextEncoder();
            const passwordKey = await crypto.subtle.importKey(
                'raw',
                encoder.encode(password),
                'PBKDF2',
                false,
                ['deriveBits', 'deriveKey']
            );
            
            const key = await crypto.subtle.deriveKey(
                {
                    name: 'PBKDF2',
                    salt: salt,
                    iterations: 100000,
                    hash: 'SHA-512'
                },
                passwordKey,
                { name: 'AES-GCM', length: 256 },
                false,
                ['encrypt', 'decrypt']
            );
            
            const iv = crypto.getRandomValues(new Uint8Array(12));
            
            const encrypted = await crypto.subtle.encrypt(
                {
                    name: 'AES-GCM',
                    iv: iv
                },
                key,
                data
            );
            
            return {
                encrypted: new Uint8Array(encrypted),
                iv: iv,
                salt: salt
            };
        }

        // ===== CAMADA 5: Rede Feistel (Revers√≠vel executando rounds na ordem inversa) =====
        function applyFeistelNetwork(data, seed, rounds) {
            const result = new Uint8Array(data.length);
            const blockSize = 8;
            
            for (let i = 0; i < data.length; i += blockSize) {
                const block = data.slice(i, Math.min(i + blockSize, data.length));
                const encrypted = feistelBlock(block, seed, rounds);
                result.set(encrypted, i);
            }
            
            return result;
        }

        function feistelBlock(block, seed, rounds) {
            if (block.length < 2) return block;
            
            const mid = Math.floor(block.length / 2);
            let left = block.slice(0, mid);
            let right = block.slice(mid);
            
            for (let round = 0; round < rounds; round++) {
                const roundKey = generateRoundKey(seed, round);
                const temp = new Uint8Array(left.length);
                
                for (let i = 0; i < left.length; i++) {
                    temp[i] = left[i];
                }
                
                left = right;
                right = new Uint8Array(temp.length);
                for (let i = 0; i < temp.length && i < right.length; i++) {
                    right[i] = temp[i] ^ roundKey[i % roundKey.length] ^ (right[i] || 0);
                }
            }
            
            const result = new Uint8Array(block.length);
            result.set(left, 0);
            result.set(right, left.length);
            return result;
        }

        function generateRoundKey(seed, round) {
            const key = new Uint8Array(8);
            let hash = simpleHash(seed + round.toString());
            
            for (let i = 0; i < 8; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                key[i] = (hash >> (i * 4)) & 0xFF;
            }
            
            return key;
        }

        // ===== CAMADA 6: Bit-Shifting Metam√≥rfico (Revers√≠vel com shift oposto) =====
        function applyMetamorphicShift(data, seed) {
            const result = new Uint8Array(data.length);
            let hash = simpleHash(seed);
            
            for (let i = 0; i < data.length; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                const shift = (hash % 5) + 1;
                result[i] = ((data[i] << shift) | (data[i] >> (8 - shift))) & 0xFF;
            }
            
            return result;
        }

        // ===== CAMADA 7: Code Morphing (Revers√≠vel com mapeamento inverso) =====
        function applyCodeMorphing(data, seed) {
            const result = new Uint8Array(data.length);
            const morphMap = generateMorphMap(seed);
            
            for (let i = 0; i < data.length; i++) {
                const pattern = (data[i] << 8) | (data[(i + 1) % data.length]);
                const morphed = morphPattern(pattern, morphMap);
                result[i] = (morphed >> 8) & 0xFF;
            }
            
            return result;
        }

        function generateMorphMap(seed) {
            let hash = simpleHash(seed);
            const map = [];
            
            for (let i = 0; i < 256; i++) {
                hash = ((hash * 1103515245) + 12345) & 0x7fffffff;
                map[i] = hash & 0xFFFF;
            }
            
            return map;
        }

        function morphPattern(pattern, map) {
            const index = pattern & 0xFF;
            return (pattern ^ map[index]) & 0xFFFF;
        }

        // ===== Fun√ß√£o auxiliar de hash simples =====
        function simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash = hash & 0x7fffffff;
            }
            return Math.abs(hash);
        }

        async function generateIntegrityHash(data) {
            try {
                const hashBuffer = await crypto.subtle.digest('SHA-512', data);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            } catch (e) {
                let h0 = 0x6a09e667, h1 = 0xbb67ae85;
                let h2 = 0x3c6ef372, h3 = 0xa54ff53a;
                
                const chunkSize = 64;
                for (let i = 0; i < data.length; i += chunkSize) {
                    const chunk = data.slice(i, i + chunkSize);
                    
                    for (let j = 0; j < chunk.length; j++) {
                        h0 = ((h0 << 5) - h0) + chunk[j];
                        h1 = ((h1 << 7) - h1) ^ chunk[j];
                        h2 = ((h2 << 9) - h2) + (chunk[j] * 31);
                        h3 = ((h3 << 11) - h3) ^ (chunk[j] * 17);
                    }
                    
                    h0 = h0 & 0xffffffff;
                    h1 = h1 & 0xffffffff;
                    h2 = h2 & 0xffffffff;
                    h3 = h3 & 0xffffffff;
                }
                
                return (Math.abs(h0).toString(16).padStart(8, '0') +
                        Math.abs(h1).toString(16).padStart(8, '0') +
                        Math.abs(h2).toString(16).padStart(8, '0') +
                        Math.abs(h3).toString(16).padStart(8, '0'));
            }
        }

        function downloadFile(data, originalName, hash) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const nameParts = originalName.split('.');
            const ext = nameParts.pop();
            const baseName = nameParts.join('.');
            
            a.href = url;
            a.download = `${baseName}_quasar.${ext}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Hash SHA-512:', hash);
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function resetInterface() {
            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
            status.style.display = 'none';
            fileName.style.display = 'none';
            fileInput.value = '';
            selectedFile = null;
            encryptBtn.disabled = true;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        console.log('‚ö° QuasarProtect iniciado');
        console.log('üõ°Ô∏è 10 camadas de prote√ß√£o ativas + Scan Antiv√≠rus');
        console.log('üîê AES-256-GCM + RC4Drop + Polimorfismo + Metamorfismo + Ofusca√ß√£o');
        console.log('ü¶† Scan heur√≠stico antiv√≠rus ativo');
    </script>
</body>
</html>
