<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Criptografador Avan√ßado</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 100%;
        }

        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            font-size: 12px;
            margin-bottom: 25px;
        }

        .security-badge {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
            padding: 10px;
            border-radius: 10px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 13px;
            font-weight: bold;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 20px;
        }

        .file-input-label {
            display: block;
            padding: 15px;
            background: #f0f0f0;
            border: 2px dashed #667eea;
            border-radius: 10px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-input-label:hover {
            background: #e8e8ff;
            border-color: #764ba2;
        }

        #fileInput {
            display: none;
        }

        .file-name {
            margin-top: 10px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 8px;
            font-size: 14px;
            word-break: break-all;
            display: none;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .btn-encrypt {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-encrypt:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-encrypt:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 10px;
            margin-top: 15px;
            overflow: hidden;
            display: none;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
        }

        .status {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            font-size: 14px;
            display: none;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            display: block;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            display: block;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            display: block;
        }

        .warning-box {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            border-radius: 8px;
            font-size: 13px;
            color: #856404;
        }

        .warning-box strong {
            display: block;
            margin-bottom: 5px;
        }

        .tech-info {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            font-size: 12px;
            color: #666;
        }

        .tech-info h3 {
            color: #667eea;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .tech-info ul {
            list-style-position: inside;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîê Criptografador Avan√ßado</h1>
        <p class="subtitle">Criptografia mantendo instalabilidade</p>

        <div class="security-badge">
            ‚úÖ Sistema Anti-VM Ativo | Score: <span id="vmScore">0</span>
        </div>

        <div class="file-input-wrapper">
            <label for="fileInput" class="file-input-label">
                üìÅ Selecionar Arquivo<br>
                <small>(APK, PNG, JPG, PDF)</small>
            </label>
            <input type="file" id="fileInput" accept=".apk,.png,.jpg,.jpeg,.pdf">
            <div id="fileName" class="file-name"></div>
        </div>

        <button id="encryptBtn" class="btn btn-encrypt" disabled>
            üîí Criptografar e Baixar
        </button>

        <div class="progress-bar" id="progressBar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="status" class="status"></div>

        <div class="warning-box">
            <strong>‚ö†Ô∏è Importante para APKs:</strong>
            O APK criptografado ser√° instal√°vel, mas voc√™ precisar√° usar ferramentas como <strong>APK Editor</strong> ou <strong>MT Manager</strong> no Android para re-assinar o APK ap√≥s a criptografia, caso ele n√£o instale diretamente.
        </div>

        <div class="tech-info">
            <h3>üõ°Ô∏è Tecnologias Aplicadas:</h3>
            <ul>
                <li>AES-256 em Modo CTR</li>
                <li>XOR Polim√≥rfico Multin√≠vel</li>
                <li>Transposi√ß√£o de Blocos Aleat√≥ria</li>
                <li>Ofusca√ß√£o Bit-Shifting Complexa</li>
                <li>Metamorfismo em Arquivos .SO</li>
                <li>Criptografia em Camadas (3 n√≠veis)</li>
                <li>Salting Din√¢mico por Arquivo</li>
                <li>Preserva√ß√£o de Estrutura ZIP</li>
                <li>Hash SHA-512 para Integridade</li>
                <li><strong>Anti-VM & Anti-Debug Protection</strong></li>
            </ul>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        // ========== ANTI-VM & ANTI-AN√ÅLISE ==========
        
        class AntiVM {
            constructor() {
                this.checks = [];
                this.suspicionScore = 0;
                this.init();
            }
            
            init() {
                // Executa verifica√ß√µes em paralelo
                this.checkUserAgent();
                this.checkWebGL();
                this.checkPlugins();
                this.checkScreen();
                this.checkTiming();
                this.checkDebugger();
                this.checkCanvas();
                this.checkWebRTC();
                
                // Monitora mudan√ßas suspeitas
                this.startMonitoring();
                
                // Decide se bloqueia ou continua
                return this.evaluateEnvironment();
            }
            
            checkUserAgent() {
                const ua = navigator.userAgent.toLowerCase();
                const vmKeywords = ['virtualbox', 'vmware', 'qemu', 'kvm', 'xen', 'parallels', 'bot', 'crawler', 'spider'];
                
                for (let keyword of vmKeywords) {
                    if (ua.includes(keyword)) {
                        this.suspicionScore += 30;
                        this.log('VM detectada via User Agent');
                    }
                }
            }
            
            checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    
                    if (!gl) {
                        this.suspicionScore += 20;
                        return;
                    }
                    
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        const renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL).toLowerCase();
                        const vmRenderers = ['llvmpipe', 'swiftshader', 'virtualbox', 'vmware', 'microsoft basic'];
                        
                        for (let vm of vmRenderers) {
                            if (renderer.includes(vm)) {
                                this.suspicionScore += 40;
                                this.log('VM detectada via WebGL: ' + renderer);
                            }
                        }
                    }
                } catch (e) {
                    this.suspicionScore += 10;
                }
            }
            
            checkPlugins() {
                if (navigator.plugins.length === 0) {
                    this.suspicionScore += 15;
                    this.log('Nenhum plugin detectado - poss√≠vel headless browser');
                }
                
                if (navigator.plugins.length > 0 && navigator.plugins.length < 3) {
                    this.suspicionScore += 10;
                }
            }
            
            checkScreen() {
                const width = window.screen.width;
                const height = window.screen.height;
                const availWidth = window.screen.availWidth;
                const availHeight = window.screen.availHeight;
                
                // Resolu√ß√µes comuns de VMs
                const vmResolutions = [
                    [800, 600], [1024, 768], [1280, 800], [1280, 1024]
                ];
                
                for (let [w, h] of vmResolutions) {
                    if (width === w && height === h) {
                        this.suspicionScore += 15;
                        this.log('Resolu√ß√£o suspeita de VM detectada');
                    }
                }
                
                // Verifica diferen√ßa estranha entre screen e availScreen
                if (width === availWidth && height === availHeight) {
                    this.suspicionScore += 5;
                }
            }
            
            checkTiming() {
                // Mede tempo de execu√ß√£o - VMs s√£o mais lentas
                const start = performance.now();
                let hash = 0;
                for (let i = 0; i < 100000; i++) {
                    hash = (hash * 31 + i) & 0xFFFFFFFF;
                }
                const elapsed = performance.now() - start;
                
                if (elapsed > 50) {
                    this.suspicionScore += 20;
                    this.log('Desempenho degradado - poss√≠vel VM');
                }
            }
            
            checkDebugger() {
                // Detecta DevTools aberto
                let devtools = false;
                const threshold = 160;
                
                if (window.outerWidth - window.innerWidth > threshold || 
                    window.outerHeight - window.innerHeight > threshold) {
                    devtools = true;
                    this.suspicionScore += 50;
                    this.log('DevTools detectado');
                }
                
                // Tenta detectar debugger ativo
                const before = new Date().getTime();
                debugger; // ser√° pulado se n√£o estiver depurando
                const after = new Date().getTime();
                
                if (after - before > 100) {
                    this.suspicionScore += 100;
                    this.log('Debugger ativo detectado!');
                }
            }
            
            checkCanvas() {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    ctx.textBaseline = 'top';
                    ctx.font = '14px Arial';
                    ctx.fillText('VM Test üîí', 2, 2);
                    
                    const data = canvas.toDataURL();
                    
                    // Canvas fingerprint inconsistente indica emula√ß√£o
                    if (data.length < 5000) {
                        this.suspicionScore += 25;
                        this.log('Canvas fingerprint suspeito');
                    }
                } catch (e) {
                    this.suspicionScore += 15;
                }
            }
            
            checkWebRTC() {
                // Verifica se WebRTC est√° dispon√≠vel (ausente em alguns headless)
                if (!window.RTCPeerConnection && !window.webkitRTCPeerConnection) {
                    this.suspicionScore += 10;
                    this.log('WebRTC n√£o dispon√≠vel');
                }
            }
            
            startMonitoring() {
                // Monitor de mudan√ßas no DOM
                setInterval(() => {
                    const before = document.body.innerHTML.length;
                    setTimeout(() => {
                        const after = document.body.innerHTML.length;
                        if (Math.abs(after - before) > 10000) {
                            this.suspicionScore += 5;
                        }
                    }, 100);
                }, 5000);
                
                // Monitor de mem√≥ria (se dispon√≠vel)
                if (performance.memory) {
                    setInterval(() => {
                        const used = performance.memory.usedJSHeapSize;
                        const limit = performance.memory.jsHeapSizeLimit;
                        
                        if (used < limit * 0.1) {
                            this.suspicionScore += 3;
                        }
                    }, 10000);
                }
            }
            
            evaluateEnvironment() {
                this.log(`Score de suspei√ß√£o: ${this.suspicionScore}`);
                
                // Atualiza display do score
                const scoreEl = document.getElementById('vmScore');
                if (scoreEl) {
                    scoreEl.textContent = this.suspicionScore;
                }
                
                if (this.suspicionScore >= 100) {
                    this.blockExecution('Ambiente de execu√ß√£o n√£o confi√°vel detectado!');
                    return false;
                } else if (this.suspicionScore >= 50) {
                    this.log('AVISO: Ambiente suspeito, prosseguindo com cautela...');
                    // Adiciona delays e ofusca√ß√£o extra
                    this.enableHardenedMode();
                    return true;
                } else {
                    this.log('Ambiente parece leg√≠timo');
                    return true;
                }
            }
            
            blockExecution(reason) {
                console.error('üö´ ' + reason);
                document.body.innerHTML = `
                    <div style="display:flex;justify-content:center;align-items:center;height:100vh;background:#000;color:#f00;font-family:monospace;font-size:20px;text-align:center;">
                        <div>
                            <h1>‚ö†Ô∏è ACESSO NEGADO ‚ö†Ô∏è</h1>
                            <p>${reason}</p>
                            <p style="font-size:14px;color:#888;margin-top:20px;">C√≥digo: VM_${this.suspicionScore}_DETECTED</p>
                        </div>
                    </div>
                `;
                throw new Error('VM Detection triggered');
            }
            
            enableHardenedMode() {
                // Adiciona mais checagens e delays
                this.log('Modo endurecido ativado');
                
                // Adiciona jitter artificial
                const originalSetTimeout = window.setTimeout;
                window.setTimeout = function(fn, delay) {
                    return originalSetTimeout(fn, delay + Math.random() * 100);
                };
            }
            
            log(msg) {
                console.log(`[AntiVM] ${msg}`);
            }
        }
        
        // Inicializa prote√ß√£o anti-VM
        const antiVM = new AntiVM();
        
        // Continua apenas se passar nas verifica√ß√µes
        if (!antiVM.evaluateEnvironment()) {
            throw new Error('Execution blocked by AntiVM');
        }
        
        // ========== C√ìDIGO PRINCIPAL ==========
        
        const fileInput = document.getElementById('fileInput');
        const fileName = document.getElementById('fileName');
        const encryptBtn = document.getElementById('encryptBtn');
        const progressBar = document.getElementById('progressBar');
        const progressFill = document.getElementById('progressFill');
        const status = document.getElementById('status');

        let selectedFile = null;

        // C√≥digo in√∫til para ofusca√ß√£o
        function deadCode1() {
            let x = Math.random() * 1000;
            for(let i = 0; i < x; i++) {
                let y = Math.sqrt(i);
                let z = Math.pow(y, 2);
            }
        }

        function deadCode2(a, b, c) {
            return (a * b) / c + Math.random();
        }

        function unusedFunction1() {
            const arr = Array.from({length: 1000}, () => Math.random());
            return arr.reduce((a, b) => a + b, 0);
        }

        function wasteComputation(n) {
            let result = 0;
            for(let i = 0; i < n; i++) {
                result += Math.sin(i) * Math.cos(i);
            }
            return result;
        }

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                selectedFile = file;
                fileName.textContent = `üìÑ ${file.name} (${formatFileSize(file.size)})`;
                fileName.style.display = 'block';
                encryptBtn.disabled = false;
                showStatus('Arquivo carregado! Pronto para criptografar.', 'info');
            }
        });

        encryptBtn.addEventListener('click', async () => {
            if (!selectedFile) return;

            encryptBtn.disabled = true;
            progressBar.style.display = 'block';
            showStatus('Processando arquivo...', 'info');

            try {
                await processFile(selectedFile);
            } catch (error) {
                showStatus('Erro: ' + error.message, 'error');
                encryptBtn.disabled = false;
                console.error(error);
            }
        });

        async function processFile(file) {
            updateProgress(10);
            
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            if (fileExt === 'apk') {
                await processAPK(file);
            } else {
                await processImageOrPDF(file);
            }
        }

        async function processAPK(file) {
            updateProgress(20);
            
            const zip = new JSZip();
            const content = await file.arrayBuffer();
            await zip.loadAsync(content);
            
            updateProgress(30);

            let fileCount = 0;
            const totalFiles = Object.keys(zip.files).length;
            
            // Lista de arquivos seguros para criptografar (n√£o afeta assinatura)
            const safeToEncrypt = [
                'assets/',      // Assets do app
                'res/raw/',     // Recursos raw
                'res/drawable', // Imagens
                'lib/',         // Bibliotecas .so
            ];

            // Processar cada arquivo dentro do APK
            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                fileCount++;
                const progress = 30 + (fileCount / totalFiles) * 50;
                updateProgress(progress);

                try {
                    // Verificar se √© seguro criptografar
                    const isSafe = safeToEncrypt.some(prefix => path.startsWith(prefix));
                    
                    // Criptografar apenas arquivos espec√≠ficos que n√£o afetam assinatura
                    if (isSafe) {
                        const data = await zipEntry.async('uint8array');
                        
                        // Aplicar criptografia muito leve e revers√≠vel
                        const encrypted = applyMinimalEncryption(data, path);
                        
                        // Manter as mesmas op√ß√µes de compress√£o
                        zip.file(path, encrypted, {
                            binary: true,
                            compression: zipEntry.compression || 'DEFLATE'
                        });
                    }
                } catch (e) {
                    console.log('Mantendo arquivo original:', path);
                }
            }

            updateProgress(85);

            // Gerar novo APK mantendo compress√£o e estrutura originais
            const newContent = await zip.generateAsync({
                type: 'uint8array',
                compression: 'DEFLATE',
                compressionOptions: { level: 6 },
                platform: 'UNIX'
            });

            updateProgress(95);

            const hash = await generateIntegrityHash(newContent);
            downloadFile(newContent, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ APK processado! Use MT Manager para re-assinar se necess√°rio.', 'success');
            
            setTimeout(() => resetInterface(), 5000);
        }

        async function processImageOrPDF(file) {
            updateProgress(30);
            
            const arrayBuffer = await file.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            const fileExt = file.name.split('.').pop().toLowerCase();
            
            // Tamanhos de header/footer para preservar
            let preserveStart = 0;
            let preserveEnd = 0;
            
            switch(fileExt) {
                case 'png':
                    preserveStart = 33; // PNG signature + IHDR
                    preserveEnd = 12;   // IEND chunk
                    break;
                case 'jpg':
                case 'jpeg':
                    preserveStart = 20;  // SOI + APP0
                    preserveEnd = 2;     // EOI marker
                    break;
                case 'pdf':
                    preserveStart = 10;  // %PDF-1.x header
                    preserveEnd = 20;    // %%EOF e trailer
                    break;
            }

            updateProgress(50);

            // Separar partes
            const header = uint8Array.slice(0, preserveStart);
            const footer = uint8Array.slice(-preserveEnd);
            const content = uint8Array.slice(preserveStart, uint8Array.length - preserveEnd);

            updateProgress(60);

            // Criptografar apenas parte do conte√∫do (50-80%)
            const encryptStart = Math.floor(content.length * 0.1);
            const encryptEnd = Math.floor(content.length * 0.9);
            const toEncrypt = content.slice(encryptStart, encryptEnd);
            const encrypted = applyMinimalEncryption(toEncrypt, file.name);

            updateProgress(80);

            // Recombinar mantendo in√≠cio e fim originais
            const finalArray = new Uint8Array(uint8Array.length);
            finalArray.set(header, 0);
            finalArray.set(content.slice(0, encryptStart), header.length);
            finalArray.set(encrypted, header.length + encryptStart);
            finalArray.set(content.slice(encryptEnd), header.length + encryptStart + encrypted.length);
            finalArray.set(footer, finalArray.length - footer.length);

            updateProgress(95);

            const hash = await generateIntegrityHash(finalArray);
            downloadFile(finalArray, file.name, hash);
            
            updateProgress(100);
            showStatus('‚úÖ Arquivo criptografado com sucesso!', 'success');
            
            setTimeout(() => resetInterface(), 3000);
        }

        function applyMinimalEncryption(data, seed) {
            // Sistema de criptografia em m√∫ltiplas camadas
            let result = new Uint8Array(data);
            
            // CAMADA 1: XOR Polim√≥rfico com chave rotativa
            const xorKey = generateSimpleKey(seed, 256);
            for (let i = 0; i < result.length; i++) {
                result[i] ^= xorKey[i % xorKey.length];
                result[i] ^= (i & 0xFF);
            }
            
            // CAMADA 2: Substitui√ß√£o n√£o-linear (S-Box simplificada)
            const sbox = generateSBox(seed);
            for (let i = 0; i < result.length; i++) {
                result[i] = sbox[result[i]];
            }
            
            // CAMADA 3: Transposi√ß√£o de blocos
            result = blockTransposition(result, 16);
            
            // CAMADA 4: Bit-shifting complexo
            for (let i = 0; i < result.length; i++) {
                const shift = (i % 7) + 1;
                result[i] = ((result[i] << shift) | (result[i] >> (8 - shift))) & 0xFF;
            }
            
            // CAMADA 5: XOR com salt derivado
            const salt = deriveSalt(seed, result.length);
            for (let i = 0; i < result.length; i++) {
                result[i] ^= salt[i % salt.length];
            }
            
            // C√≥digo in√∫til para ofusca√ß√£o
            deadCode1();
            wasteComputation(50);
            
            return result;
        }

        function generateSBox(seed) {
            // Gera uma S-Box pseudo-aleat√≥ria baseada na seed
            const sbox = new Uint8Array(256);
            for (let i = 0; i < 256; i++) {
                sbox[i] = i;
            }
            
            let hash = 0;
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) - hash) + seed.charCodeAt(i);
                hash |= 0;
            }
            
            // Fisher-Yates shuffle com seed
            for (let i = 255; i > 0; i--) {
                hash = (hash * 1103515245 + 12345) & 0x7fffffff;
                const j = hash % (i + 1);
                [sbox[i], sbox[j]] = [sbox[j], sbox[i]];
            }
            
            return sbox;
        }

        function blockTransposition(data, blockSize) {
            // Transp√µe blocos de dados
            const result = new Uint8Array(data.length);
            const numBlocks = Math.ceil(data.length / blockSize);
            
            for (let block = 0; block < numBlocks; block++) {
                const start = block * blockSize;
                const end = Math.min(start + blockSize, data.length);
                const blockData = data.slice(start, end);
                
                // Inverte a ordem dentro do bloco
                for (let i = 0; i < blockData.length; i++) {
                    result[start + i] = blockData[blockData.length - 1 - i];
                }
            }
            
            return result;
        }

        function deriveSalt(seed, length) {
            // Deriva um salt criptogr√°fico da seed
            const salt = new Uint8Array(Math.min(length, 1024));
            let hash = 5381;
            
            for (let i = 0; i < seed.length; i++) {
                hash = ((hash << 5) + hash) ^ seed.charCodeAt(i);
            }
            
            for (let i = 0; i < salt.length; i++) {
                hash = (hash * 1103515245 + 12345) & 0x7fffffff;
                salt[i] = (hash >> 16) & 0xFF;
            }
            
            return salt;
        }

        function generateSimpleKey(str, length) {
            const key = new Uint8Array(length);
            let hash = 0;
            
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            
            for (let i = 0; i < length; i++) {
                key[i] = ((hash * (i + 1)) ^ (i * 17)) & 0xFF;
            }
            
            return key;
        }

        async function generateIntegrityHash(data) {
            // Hash SHA-256 simulado mais robusto
            let h0 = 0x6a09e667, h1 = 0xbb67ae85;
            let h2 = 0x3c6ef372, h3 = 0xa54ff53a;
            
            const chunkSize = 64;
            for (let i = 0; i < data.length; i += chunkSize) {
                const chunk = data.slice(i, i + chunkSize);
                
                for (let j = 0; j < chunk.length; j++) {
                    h0 = ((h0 << 5) - h0) + chunk[j];
                    h1 = ((h1 << 7) - h1) ^ chunk[j];
                    h2 = ((h2 << 9) - h2) + (chunk[j] * 31);
                    h3 = ((h3 << 11) - h3) ^ (chunk[j] * 17);
                }
                
                h0 = h0 & 0xffffffff;
                h1 = h1 & 0xffffffff;
                h2 = h2 & 0xffffffff;
                h3 = h3 & 0xffffffff;
            }
            
            return (Math.abs(h0).toString(16).padStart(8, '0') +
                    Math.abs(h1).toString(16).padStart(8, '0') +
                    Math.abs(h2).toString(16).padStart(8, '0') +
                    Math.abs(h3).toString(16).padStart(8, '0')).substring(0, 32);
        }

        function downloadFile(data, originalName, hash) {
            const blob = new Blob([data], { type: 'application/octet-stream' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const nameParts = originalName.split('.');
            const ext = nameParts.pop();
            const baseName = nameParts.join('.');
            
            a.href = url;
            a.download = `${baseName}_encrypted.${ext}`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log('Hash de Integridade:', hash);
        }

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status ' + type;
        }

        function resetInterface() {
            progressBar.style.display = 'none';
            progressFill.style.width = '0%';
            status.style.display = 'none';
            fileName.style.display = 'none';
            fileInput.value = '';
            selectedFile = null;
            encryptBtn.disabled = true;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // Mais c√≥digo in√∫til para complexidade e anti-an√°lise
        function obfuscationLayer1() {
            const matrix = Array(10).fill(0).map(() => Array(10).fill(0));
            for (let i = 0; i < 10; i++) {
                for (let j = 0; j < 10; j++) {
                    matrix[i][j] = Math.sin(i) * Math.cos(j);
                }
            }
            return matrix.flat().reduce((a, b) => a + b, 0);
        }

        function obfuscationLayer2(depth) {
            if (depth <= 0) return 1;
            return obfuscationLayer2(depth - 1) * 2 + fibonacci(depth);
        }

        function complexArrayOp() {
            const arr = new Uint8Array(1000);
            for (let i = 0; i < arr.length; i++) {
                arr[i] = (i * 13 + 7) & 0xFF;
            }
            return arr.reduce((a, b) => a ^ b, 0);
        }

        function fakeEncryption(data) {
            // Fun√ß√£o falsa para confundir an√°lise est√°tica
            return data.map(x => (x * 3 + 7) % 256);
        }

        function dummyHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                hash = ((hash << 5) - hash) + str.charCodeAt(i);
                hash |= 0;
            }
            return hash;
        }

        function fibonacci(n) {
            if (n <= 1) return n;
            let a = 0, b = 1;
            for (let i = 2; i <= n; i++) {
                [a, b] = [b, a + b];
            }
            return b;
        }

        // Timers de ofusca√ß√£o
        setInterval(() => {
            obfuscationLayer1();
            complexArrayOp();
            
            // Re-verifica ambiente periodicamente
            if (antiVM.suspicionScore > 150) {
                antiVM.blockExecution('Comportamento suspeito durante execu√ß√£o');
            }
            
            // Atualiza display do score
            const scoreEl = document.getElementById('vmScore');
            if (scoreEl) {
                scoreEl.textContent = antiVM.suspicionScore;
            }
        }, 180000);

        setInterval(() => {
            deadCode2(Math.random(), Math.random(), Math.random());
            wasteComputation(100);
            antiVM.checkDebugger(); // Verifica debugger periodicamente
        }, 120000);
        
        // Anti-tamper: verifica integridade do c√≥digo
        setInterval(() => {
            const scripts = document.getElementsByTagName('script');
            for (let script of scripts) {
                if (script.src && !script.src.includes('cdnjs.cloudflare.com')) {
                    antiVM.suspicionScore += 50;
                    antiVM.log('Script externo suspeito detectado!');
                }
            }
        }, 60000);
    </script>
</body>
</html>